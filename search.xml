<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git-tutorial]]></title>
    <url>%2F2020%2F04%2F28%2Fgit-tutorial%2F</url>
    <content type="text"><![CDATA[git网上有很多经典的教程，比如廖雪峰的Git教程 不过，秉承“只有自己总结的东西才是自己的”观念，还是做了自己的笔记。 学习的顺序应该为： 学习廖的课程 做自己的笔记，形成自己的知识 再回去好好细读廖的教程，发现一些之前未发现的、未理解的内容 git help 的使用工具，都是熟能生巧。掌握基本方法，多看官方git help 才是正道。 123456# help 功能全览git help# 查看帮助手册git help git# 如果不知道下一步怎么操作git status #git status会列出当前的状态，并提示接下来的操作！！ git的优势 分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！ 远程库既可以作为备份，又可以让其他人通过该仓库来协作。 因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。 git线上网页版使用说明git本地提交之后，线上有个最后审核步骤，有实操后总结在这里。 git的基本操作安装git官网下载，一路next。（windows） 设置username和email123# --global是全局参数，对局部仓库也可以单独设置name和email$ git config --global user.name "Your Name"$ git config --global user.email "email@example.com" 使用SSH协议连接本地库与远程库id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 123456# 本地的git仓库与远程库使用SSH（secure shell）进行加密传输# 本地创建SSH Key # 查看根目录下是否有.ssh文件，以及.ssh/id_rsa 和.ssh/id_rsa_pub文件是否存在 #不存在 ssh -keygen -t rsa -C "youremail@example.com"# 将公钥放在GitHub上面 为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。 当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。 最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。 摘抄自https://www.liaoxuefeng.com/wiki/896043488029600/896954117292416 Q: 远程库有什么用呢？ A: GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作 先有本地库，再有远程库本地仓库初始化 123456# 仓库 repository# 本地仓库初始化git init# 查看git配置文件ls -ah# 或者克隆远程库git clone（TODO） 本地文件新建提交仓库 1234# 多次add 一次提交git add fileName1git add fileName2git commit -m "comment content" 提交完毕复核 12345678# 修改了fileName1git status# 查看某个文件修改前后差别（已经 add了会回退到未add状态）# 脑中要有文件状态转换图（第一幅图）# ！！diff 比较的是 add之前和之后文件的差异！！git diff fileName1git add fileName1git commit -m "revise fileName1" 版本回退（游戏存档读档） 1234567891011# commit的作用类似于*存档*，当出现意外，可以回到这个存档点重新开始# 查看存档点,存档点是一个HEAD指针，HEAD^表示当前存档点的前一个存档点，HEAD^^上上存档点# HEAD~100：前100个存档点git log#简洁版展示git log --pretty=oneline#显示commit id git relog#跳转到指定存档点 #HEAD指针可以是: 1. HEAD^这种类型的 2.指定的commit idgit reset --hard HEAD指针 必须记住的第一张图(图一)：文件的状态流转图 图中存在四个对象： 工作区 workspace 版本库 repository 暂存区 stage 主分支 master 包含的内容上：{stage} &gt;= {master} 详说git diff 12345# 根据图一# 比较工作区workspace与暂存区stage的区别git diff# 比较版本库主分支master与工作区workspace的区别git diff HEAD -- fileName 撤销修改 第6点说到的版本回退是指stage与master一致下（stage为空），将当前maste版本切换回之前的master版本，工作区同步修改。 撤销修改指的是撤销一个小的改动，涉及workspace/repository/stage/master之间状态的转移。 123456789#工作区修改，暂存区和主分支没有变化 撤销修改git status #根据提示敲入下一行命令git restore fileName #撤销工作区的修改（本质是用版本库覆盖工作区）#工作区修改，提交到暂存区，主分支没有变化 撤销修改git statusgit restore --unstage fileName #撤销暂存区的修改git restore fileName #撤销工作区的修改# 修改已经commit 撤销修改(版本回退)git reset --hard HEAD^ 文件删除12345678910111213141516# 新增文件并add、commitgit add test.txtgit commit -m "add test.txt"$ git statusOn branch masterChanges not staged for commit: (use "git add/rm &lt;file&gt;..." to update what will be committed) (use "git restore &lt;file&gt;..." to discard changes in working directory) deleted: test.txt#根据提示 # 如果本地删除是误操作git restore test.txt # 如果确实删除某个文件git add test.txt # orgit rm test.txtgit commit -m "delete test.txt" 建立远程库分支与本地分支连接123456789101112131415# 1.先有本地库，再有远程库 # 1.1 与远程仓库建立连接 # 连接远程（remote）添加git@github.com:ShanggguanZpure/learn.git为远程仓库，并命名为origin git remote add origin git@github.com:ShangguanZpure/learngit.git # 1.2 将本地文件推送到远程库对应分支 #第一次提交:关联（-u）本地master分支内容到远程仓库（origin）的master分支,并推送（push）本地master分支内容到远程仓库（origin）的master分支 git push -u origin master #第二次及以上提交：本地推送到远程仓库的master git push origin master # 推送本地指定分支（branch-name）到远程库(origin)指定分支(origin/branch-name) git push origin branch-name origin/branch-name #远程分支可以省略，会找对应分支合并 # 2.先有远程库，再有本地库 # 克隆远程库内容git clone git@github.com:ShangguanZpure/gitskills.git 分支管理什么时候建立分支分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。 现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。 创建与合并分支123456789101112131415161718192021222324# 查看分支：git branch#创建分支：git branch &lt;name&gt;#切换分支：git checkout &lt;name&gt; #或者git switch &lt;name&gt;#创建+切换分支：git checkout -b &lt;name&gt; #或者git switch -c &lt;name&gt;#合并某分支到当前分支：git merge &lt;name&gt;#删除分支：git branch -d &lt;name&gt;#分支合并默认为fast forward,并且删除分支后，合并记录不保留，使用 --no-ff就会按照普通模式合并，并做一次commit提交，可以保留合并记录。举例如下： git switch -c dev vi readme.txt #修改readme.txt文件进行保存 git add readme.txt git commit -m "merge -no-ff test" git switch master git merge --no-ff -m "merge with dev" dev git branch -d dev git log --graph --pretty=oneline --abbrrev-commit 解决冲突12345678910# 产生冲突的原因：两个分支修改了同一个地方，且不一致。git merge feature1 #产生冲突vi conflictedFileName#手动修改不一致地方git add conflictedFileNamegit commit -m "conflict fixed"#删除分支git branch -d feature1#查看分支合并图$ git log --graph --pretty=oneline --abbrev-commit Bug分支：修复紧急Bug操作暂存（stash）现有分支的工作，切换到Bug分支修复（待测试） 1234567891011121314151617181920212223242526272829#当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交.# 1.存放dev分支工作区和暂存区的内容，包含：暂存区未提交的内容（暂存区与主分支区别），工作区未提交到暂存区的内容（工作区与暂存区的区别）workspace - stage - mastergit stash# 2. 确认在哪个分支上修复（假设为master，当然也可以是其他分支）git switch master# 3.从master分支新建Bug分支git switch -c issue-101# 4.修复Bug# 5.提交修改git add readme.txtgit commit -m "fix bug 101"# 6.切换到主分支，提交修改git switch mastergit merge --no-ff -m "merged bug fix 101" issue-101# 7.切换回dev分支继续开发git switch dev# 8.查看dev分支状态git statusgit stash list #！！！# 9.恢复之前暂存的内容git stash apply #拉取git stash drop #删除 #上面两步合成一步git stash pop #你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash git stash apply stash@&#123;0&#125;# 在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick &lt;commit&gt;命令，把bug提交的修改“复制”到当前分支，避免重复劳动。git cherry-pick 4c805e2 #！！！ Feature 分支:开发新功能开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D强行删除。 多人协作123456789101112131415161718192021222324252627282930# 查看远程库的信息$ git remote -vorigin git@github.com:michaelliao/learngit.git (fetch)origin git@github.com:michaelliao/learngit.git (push)# 推送分支 #推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上 #全格式是： git push &lt;remote&gt; local-branch-name remote/branch-name(可以省略最后一项） $ git push origin master #推送其他分支，比如dev，就改成 $ git push origin dev# 抓取分支 #要在dev分支上开发，就必须创建远程origin的dev分支到本地 $ git checkout -b dev origin/dev# 本地分支提交远程分支产生冲突 #先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送 $ git pull There is no tracking information for the current branch. Please specify which branch you want to merge with. See git-pull(1) for details. git pull &lt;remote&gt; &lt;branch&gt; If you wish to set tracking information for this branch you can do so with: git branch --set-upstream-to=origin/&lt;branch&gt; dev #git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接： $ git branch --set-upstream-to=origin/dev dev Branch 'dev' set up to track remote branch 'dev' from 'origin'. # 解决冲突后再次push $ git push origin dev commit log管理merge操作会产生一些merge commit的提交，意义不明且冗余，应该去除。 主要有以下两种情形： 多人在同一个远程分支Feature上协作，需要多次git pull别人的提交到本地合并，在合并完之后，还没push之前，使用git rebase可以将分支合并的操作整合成一条直线。 也可以是 git pull --rebase (等价于git fetch + git rebase) 背景： 本地master分支在commit1处新建分支feature，feature分支上有提交一次feature_commit1，master分支自己独立提交了一次commit2 动作： 现在feature分支合并master分支的commit2，方便做下一步开发 具体操作: 为了使得合并之后feature分支的提交记录git log --graph --pretty=oneline --abbrev-commit是一条直线，没有分叉，采用: git rebase master 本地自己独立的一个分支other（实现特定功能）合并到 dev 分支，分支other多次提交过于琐碎，希望合成一个，使用git merge --squash other,git commit -m &quot;Message&quot;。 参考： 1.https://www.liaoxuefeng.com/wiki/896043488029600/1216289527823648 2.https://blog.csdn.net/themagickeyjianan/article/details/80333645?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2 标签 tagTODO 先有远程库，再有本地库本地仓库初始化1234# 根据SSH协议，克隆（clone）版本库git@github.com:ShangguanZpure/gitskills.git到当前目录git clone git@github.com:ShangguanZpure/gitskills.git# 当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin# 从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支 多人协作123456789101112131415161718192021222324252627282930# 查看远程库的信息$ git remote -vorigin git@github.com:michaelliao/learngit.git (fetch)origin git@github.com:michaelliao/learngit.git (push)# 推送分支 #推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上 #全格式是： git push &lt;remote&gt; local-branch-name remote/branch-name(可以省略最后一项） $ git push origin master #推送其他分支，比如dev，就改成 $ git push origin dev# 抓取分支 #要在dev分支上开发，就必须创建远程origin的dev分支到本地 $ git checkout -b dev origin/dev# 本地分支提交远程分支产生冲突 #先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送 $ git pull There is no tracking information for the current branch. Please specify which branch you want to merge with. See git-pull(1) for details. git pull &lt;remote&gt; &lt;branch&gt; If you wish to set tracking information for this branch you can do so with: git branch --set-upstream-to=origin/&lt;branch&gt; dev #git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接： $ git branch --set-upstream-to=origin/dev dev Branch 'dev' set up to track remote branch 'dev' from 'origin'. # 解决冲突后再次push $ git push origin dev 小结 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 自定义Gitgit的进阶操作git使用的注意事项疑问1、 123456789101112131415161718192021222324$ git reflogf7d7681 (HEAD -&gt; master) HEAD@&#123;0&#125;: commit (merge): conflict fixed8957634 HEAD@&#123;1&#125;: commit: &amp; simple5f311b8 HEAD@&#123;2&#125;: checkout: moving from feature1 to masterc4d3fa9 (feature1) HEAD@&#123;3&#125;: commit: AND simple5f311b8 HEAD@&#123;4&#125;: checkout: moving from master to feature15f311b8 HEAD@&#123;5&#125;: merge dev: Fast-forward0da8bf7 (origin/master) HEAD@&#123;6&#125;: checkout: moving from dev to master5f311b8 HEAD@&#123;7&#125;: commit: branch test0da8bf7 (origin/master) HEAD@&#123;8&#125;: checkout: moving from master to dev0da8bf7 (origin/master) HEAD@&#123;9&#125;: commit: delete test.txt09915bb HEAD@&#123;10&#125;: commit: add test.txt131ea24 HEAD@&#123;11&#125;: reset: moving to HEAD^7fe3d31 HEAD@&#123;12&#125;: commit: error content commit131ea24 HEAD@&#123;13&#125;: commit: git tracks changesd0950e0 HEAD@&#123;14&#125;: commit: understand how stage worksd576e2b HEAD@&#123;15&#125;: reset: moving to d576e2bd87032b HEAD@&#123;16&#125;: reset: moving to HEAD^d576e2b HEAD@&#123;17&#125;: commit: add GPLd87032b HEAD@&#123;18&#125;: commit: add distribuye951d21f HEAD@&#123;19&#125;: commit (initial): creat a readme file# 第二列表示什么呢？表示具体的指针指向的位置。本地master指向“conflict fixed”。# 远程的master分支（origin/master）指向哪里呢？看到提交过程中多次出现？按理说，没有push操作，远程库应该没有变动才对。]]></content>
      <categories>
        <category>基础工具使用</category>
      </categories>
      <tags>
        <tag>管理工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[text-editor-skills]]></title>
    <url>%2F2020%2F04%2F21%2Ftext-editor-skills%2F</url>
    <content type="text"><![CDATA[文本编辑小技巧列编辑Notepad++中： 设置中首选项选择类操作许可，按住alt选中编辑的行，即可进行列元素的操作。、 比如统一的首字母大写。 批量替换给每行的开头统一添加相同内容方法： 回车换行的文本符号为\r\t 匹配每行的\r\t，替换为\r\tAddContent即可]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>文本编辑</tag>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[周日总结]]></title>
    <url>%2F2020%2F04%2F19%2F2020-04-19-summary%2F</url>
    <content type="text"><![CDATA[最近比较颓废，工作上的事情不是特别紧急，空余下来的时间里面却不想做什么事情，懒癌发作，彻底成为积极向上时候的自己最讨厌的那种人。 有自己的时间是一件多幸运的事情，可以继续了解学习自己的爱好方面的知识，比如自己之前刚开了一个头的唱歌技巧学习的坑，还为此写了一篇日记记录唱歌技巧学习笔记，可是我没有点开继续学习。为什么呢，不是特别喜欢唱歌吗，怎么就没有激情了呢？也许是认识到自己唱歌气息控制不好，声音也不好听，还找不到音准等等缺点，打击到积极性了。既然把唱歌当成自己一项爱好，那么还是坚持住，唱歌技巧的教程要看完的(TODO)。 空余的时间也是给自己技术能力充电的好机会啊，可是也没有珍惜这段时间去做这件事。想了下，也是遇到了一个小困难，刚好看到java基本类库的使用，要去了解java基本类库的用法，枯燥乏味还要记忆，因此打击了学习的积极性。这个时候其实更应该克服，学不下去的时候那就好好做好笔记(TODO)，方便下次学习更有效率些。 当然，话说话来，人的活力总有上有下，处于低谷期，什么都不做，放空下自己也没有错啦，让自己晚上刷手机刷到困，早上睡到自然醒，看看电影，补补电视剧《清平乐》，看看综艺《王牌对王牌》，听听音乐《歌手》也不见得就不好。就是怕放开自律，就如脱缰野马，难以回性，写到这里算是给自己一个提醒。 无聊时间也会想起久未联系的朋友，约着喝喝奶茶，聊聊天，刚好也能联络联络感情，但是不好的一点就是自己嘴巴还是太碎，说话也过于零散，没能良好互动，希望之后注意让自己说话有个中心，给对方留足反馈时间，形成良好交流(TODO)。 最近觉得不错的一个事情，那就是跑步还是坚持下来了，这点特别好，继续坚持吧！ 有果必有因，为啥最近会懒癌发作呢？自己觉得根源还是在职业规划上的迷惑以及学习任务艰巨两方面引起的。职业规划上，觉得银行的技术只要够用就可以，自己是无法有效得到提升的，技术提升慢的同时技术价值在行内并没有业务价值高，但是难受在业务能力提升的方法和途径自己并未有所得，提升进展缓慢。思虑职业规划同时还要学习海量的java知识，心态上隐隐觉得hold不住，因为目前看进展也很慢，才看完Spring的IOC和AOP，java基础也看了50%而已，后续等着我的还有linux运维基本知识（视频B站已收藏，183讲），SSM框架的Struts和Mybatis。 怎么办呢？ 职业规划上，先争取做好分内技术工作吧，也就是SSM框架熟悉起来，会基本的linux运维，学习数据库的基本知识，等技术的工作做完后，再发力熟悉目前正在做的业务。时间上安排，就是上半年结束之前，SSM框架熟悉完毕，今年过后，linux运维和数据库也小有了解。明年再发力开始熟悉业务。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结归纳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-funda-class]]></title>
    <url>%2F2020%2F04%2F16%2Fjava-funda-class%2F</url>
    <content type="text"><![CDATA[Java数字类1234567891011121314151617181920//double 和 float不能表示精确的小数//常规类型表示有范围限制//引入BigInterger和BigDecimal，没有范围限制//BigDecimal初始化尽量用字符串，使用double类型不准确BigDecimal bigDecimal = new BigDecimal("10");BigDecimal bigDecimal = new BigDecimal(2.3);//out:2.29365453658662... //BigDecimal做除法，记得限制输入位数System.out.println( bigDecimal.divide(new BigDecimal("3"), 3, BigDecimal.ROUND_HALF_UP));//随机数类//使用Random类或者Math.random()//具体的随机数范围查看源码注释确认Random rd = new Random();rd.nextInt();rd.nextInt(10);//[0,10)间rd.nextDouble();//[0.0,1.0)间rd.ints(5,10,100);//返回10-100之间的5个随机数Math.random();//[0.0,1.0)间System.out.println(Math.round(Math.random()*10)); 字符串相关类字符串相关类基本都要背，因为太常用了。 String类是不可变对象，concat等改变的操作都会产生一个新的对象。 123456789101112131415161718192021222324String str = "123,456,789,/*/";//增System.out.println(str.concat("aaaa"));//删、改System.out.println(str.substring(2,4));System.out.println(str.replace("123", "321"));System.out.println(str.replaceAll("[*]", "??")); //第一个表达式是正则表达式System.out.println(str.split(","));System.out.println(str.trim());//查System.out.println(str.charAt(0));System.out.println(str.concat("123"));System.out.println(str.contains("123"));System.out.println(str.indexOf("123"));System.out.println(str.length());System.out.println(str.isEmpty());//空的判断与念出来的含义相符合：如果数组不为空if(!str.isEmpty())&#123; System.out.println("no empty");&#125;//可变长字符对象有StringBuffer和StringBuilder//StringBuffer是线程同步的//StringBuilder线程不同步//.append()功能速度上StringBuilder&gt;StringBuffer&gt;String 日期相关类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//Calendarimport java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date; public class MyCalendar &#123; //格式化声明 private static SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); //日期实例 private static Calendar startDate = Calendar.getInstance(); private static Calendar endDate = Calendar.getInstance(); private static DateFormat df = DateFormat.getDateInstance(); private static Date earlydate = new Date(); private static Date latedate = new Date(); /** * 计算两个时间相差多少个年 * * @param early * @param late * @return * @throws ParseException */ public static int yearsBetween(String start, String end) throws ParseException &#123; //Str -&gt; format -&gt; set startDate.setTime(sdf.parse(start)); endDate.setTime(sdf.parse(end)); return (endDate.get(Calendar.YEAR) - startDate.get(Calendar.YEAR)); &#125; /** * 计算两个时间相差多少个月 * * @param date1 * &lt;String&gt; * @param date2 * &lt;String&gt; * @return int * @throws ParseException */ public static int monthsBetween(String start, String end) throws ParseException &#123; startDate.setTime(sdf.parse(start)); endDate.setTime(sdf.parse(end)); int result = yearsBetween(start, end) * 12 + endDate.get(Calendar.MONTH) - startDate.get(Calendar.MONTH); return result == 0 ? 1 : Math.abs(result); &#125;————————————————版权声明：本文为CSDN博主「浅沫微雨」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/L_hb123/java/article/details/59058209]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[qing-ping-le]]></title>
    <url>%2F2020%2F04%2F11%2Fqing-ping-le%2F</url>
    <content type="text"><![CDATA[官家关于大赦天下答大娘娘的话矛盾点：你把反对我的人都赦免了，告述天下朝堂已在你的掌控之中，你这是为我祈福吗？ 官家站在大娘娘的角度考虑，同意部分大娘娘的说法，但是把原因和目的上升到一个更高的维度，符合双方共同的着力点——维护大宋的江山去说明：反对你的那些人是眼光狭隘了些，但是也不是什么大奸大恶之人，还是忠君为国的能臣，释放他们让他们继续发光发热不正是为了让大宋更加的繁荣吗？]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>观后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[json解析]]></title>
    <url>%2F2020%2F04%2F09%2Fjava-json-object%2F</url>
    <content type="text"><![CDATA[json用法使用阿里的fastjson包。 1234567891011121314151617//用到的两个类import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject;//javaObj 到 jsonSrt（两种方法）String jsonStr = JSON.toJSONString(Obj);String jsonStr = JSONObject.toJSONString(Obj); //jsonStr 到javaObj（两种方法） //(1) jsonStr -&gt; JSONObject -&gt; javaObjJSONObject jsonObj = JSON.parseObject(jsonStr); //jsonStr -&gt; JSONObjectObject javaObj = JSON.toJavaObject(jsonObj, Object.class); //JSONObject -&gt; javaObj //(2)Object obj = JSON.parseObject(jsonStr, Object.class);//jsonStr -&gt; javaObj//写jsonStr注意json串的引号需要转义String jsonString = "&#123;\"name\":38,\"name\":\"mkyong\"&#125;"; 对象中有空值的处理方法(手动处理): 1234567891011class MyObject&#123;&#125;//对象转化为json对象obj -&gt; jsonStr -&gt; JSONObject;JSONObject jsonObj = JSON.parseJson(JSON.toJsonString(MyObject));//获取对象的成员变量 //反射方法获取（todo）//创建HashMap&lt;String, Object&gt; jsonMap,成员变量为key，jsonObj.get(key)为valueif(jsonObj.get(key) == null)&#123; jsonMap(key, "");&#125;else&#123; jsonMap(key, jsonObj.get(key));&#125; 例子（测试包含json串嵌套的场景通过） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.alibaba.fastjson.serializer.SerializerFeature;/** * JSON 转换 */public final class JsonUtils &#123; /** * 把Java对象转换成json字符串 * * @param object 待转化为JSON字符串的Java对象 * @return json 串 or null */ public static &lt;T&gt; String parseObjToJson(T object) &#123; String string = null; try &#123; //string = JSON.toJSONString(object); string = JSONObject.toJSONString(object, SerializerFeature.PrettyFormat); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; return string; &#125; /** * 将Json字符串信息转换成对应的Java对象 * * @param json json字符串对象 * @param c 对应的类型 */ public static &lt;T&gt; T parseJsonToObj(String json, Class&lt;T&gt; c) &#123; try &#123; //两个都是可行的，起码我测试的时候是没问题的。 //JSONObject jsonObject = JSONObject.parseObject(json);// JSONObject jsonObject = JSON.parseObject(json);// return JSON.toJavaObject(jsonObject, c); return JSON.parseObject(json, c); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; return null; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>技术文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sing_a-song]]></title>
    <url>%2F2020%2F04%2F04%2Fsing-a-song%2F</url>
    <content type="text"><![CDATA[唱歌技巧参考视频教程 第一节：使用气息 如何吸气（腹式呼吸） 练习方法： 吸气，气沉小腹，嘟嘴巴唱“都咧咪法搜”； 小诀窍：叹气的感觉，狗喘气 什么时候吸气 多听歌。 气息怎么控制： 深呼吸，憋气，加动作辅助（下蹲） 小诀窍：气往下沉，高音才上的去 第二节：找到声音的位置 说话 唱歌 微笑！打开口盖 开口音：a a a a a 闭口音：mi yi yi yi yi 分别说和唱的区别 感觉有没有用上气息 共鸣 胸腔共鸣 手放在胸前 气下沉 振动 鼻腔共鸣 手指放在鼻子，气下沉 头腔共鸣 手指一直往上找最高音，气下沉 使用颤音]]></content>
      <categories>
        <category>生活向</category>
      </categories>
      <tags>
        <tag>唱歌技巧</tag>
        <tag>喜欢的歌</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[兼听则明]]></title>
    <url>%2F2020%2F03%2F31%2F2020-03-31%2F</url>
    <content type="text"><![CDATA[我对综艺节目歌手关注越来越少了，今年注意到的时候已经播出两期了。节目虽然没看，倒是在知乎看到的些许的讨论，讨论的一个焦点是华晨宇，另一个便是黄霄云。那会关于黄霄云的讨论重点一个是说她专捡软柿子捏，奇袭毛不易，一个是说炫技大过于表达，还有一个是说情商不行的。一通这么漫无目的的浏览下来，对于黄的歌唱实力顶尖、唯比赛论和情商待提高的固执小姑凉形象就形成了。这之后开始看黄的表演就觉得歌唱的很好，但是就觉得太比赛化，唱的很动听，却没能打动我。 今天歌单随机播放循环到了一首《连名带姓》，瞬间被打动了，打开一看，正是黄的演唱，脑海中一些蹦出了疑问：那会歌手舞台听的时候怎么没有感觉？点开歌曲评论，画风与知乎上的风格天差地别，我摘几条： 歌手本来就是综艺，可怜只有黄把它当比赛； 放弃了保研，最后一门课因为档期冲突放弃了； 这届歌手中唯一一个可以让我单曲循环的歌手，其他歌手的歌都没意思，没了黄，甚至不想看，一帮老油条； 汪峰：考中央音乐学院（给你写推荐信） 林俊杰：我想要认识你 萧敬腾：天分的歌者 华晨宇：未来非常顶尖的歌手 键盘侠：没感情，只会炫技，快淘汰吧。 暂不论这些评论的是否有失偏颇，但是确实那个当下让我从正面的视角感受到了黄的认真，想赢的决心，通过《连名带姓》这首歌也感受她的真挚和实力。我诧异自己之前仅仅是看了相关的评论就莫名其妙给人贴上那些恶劣的标签，诧异自己连黄是谁都不知道的情况下就敢武断的做出判断，用有色眼镜去看待她的表演。 于是我不禁思考：一个与我们相隔十万八千里的人，怎么对她产生情感倾向？ 往往我们被动接受各种带着明显的感情倾向讯息，就容易人云亦云，不经思考给别人贴上刻板标签。如果自己亲眼所见的场景让你产生情绪，那这种情绪就是最直接你对这个人的观感，无需怀疑。如果未对一个人所做所为有过亲眼目睹，只是道听、途说，那么不要轻易做出判断，一定要看看好的说法和坏的说法，兼听则明。 对每一件事要有自己发自内心认同的判断，这个判断需要在看到好坏两面后做出。 多看你一眼，而你不搭理我的背影就会让我烦恼一整天啊，讨厌不敢行动又不会行动的自己啊。允许自己在这里小小颓一下。 可能你会说，兼听需要花费时间成本，犯不着这么较真。这也没错，但是如果可以，在给任何一个贴上标签的时候，尽量都慎重些，不了解最好就不做判断，特别是下意识的判断。]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>随想</tag>
        <tag>生活原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[how-to-live]]></title>
    <url>%2F2020%2F03%2F29%2Fhow-to-live%2F</url>
    <content type="text"><![CDATA[周五晚上在学校的论坛浏览后，有一句话一直在脑海中出现，大意是： 生活其实很纯粹，快乐也很简单，在学习的时间学习，累了就在被窝里看一部电影，疗愈自己，看完就乖乖睡觉，不要被那些琐碎的想法纠缠，没有意义。 然后周末下意识按照这样的方式去生活，在起床的时间起床，在学习的时间学习，在休息的时间就真的放下手机，好好休息，在锻炼的时间就穿好装备去锻炼，在被窝的时间就打开一部电影，好好沉浸其中。 自律的感觉、休息的感觉、偷懒的感觉都享受到了，挺不错。 生活本身是复杂的，如何让生活简单快乐是一门艺术啊。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>随想</tag>
        <tag>生活向</tag>
        <tag>零碎想法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writing-skills]]></title>
    <url>%2F2020%2F03%2F24%2Fwriting-skills%2F</url>
    <content type="text"><![CDATA[知乎评价周杰伦看看人家如何行文，做一下分析记录： 迷茫是年轻人的常事。 我在身边看到了这个时代年轻人的迷茫。我从书里看到了过去很多时代年轻人的迷茫。 身边的朋友对我说，看到许多我们已经习以为常的事情和观点跨越过一代人的鸿沟在上一代人的眼里竟如洪水猛兽般面目可憎，而他们才占据着这个社会的主流。 我告诉他不是这样的。 我给你讲个故事，这个故事是关于周杰伦的。 作者：子由链接：https://www.zhihu.com/question/21850419/answer/204892310来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java线程协作学习]]></title>
    <url>%2F2020%2F03%2F19%2Fexample-for-thread-learnning%2F</url>
    <content type="text"><![CDATA[今天学习Java多线程的协作方法，接触到了几种锁，来规定了多个线程的协作方式，今天的学习方法特别适用于说明例子化学习的好处。 例子化学习就是每一处知识点通过一个例子来比喻或者应用，判断自己掌握这个知识点的方法就是把这个例子说一遍或者实现一遍。 这种方法让每一个知识点在脑海里都是一张图，一个画面，一个场景，积累多了，脑中自成一片天地。 具体到今天的学习： 基本的读写锁Lock 应用于奶茶店买奶茶：顾客买奶茶是单独读线程协作，老板写订单和员工的读订单是分别的读写线程协作，用Lock就可以管理； 计量锁 Semaphone 对应与停车场停车：停车场的大小是固定的，多车是否可以停车，停车线程的管理用Semaphone锁管理； 门闩锁 Latch锁 对应 百米赛跑。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>随想</tag>
        <tag>总结</tag>
        <tag>学习原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架]]></title>
    <url>%2F2020%2F03%2F17%2FmicroService%2F</url>
    <content type="text"><![CDATA[自上而下学习什么是SSM框架 Spring学习已经学习结束， 使用的教程：https://www.bilibili.com/video/av47952931 笔记在代码中，在D:\course\javaProject\21-IDEA-projects Mybatis学习实现一个例子：https://segmentfault.com/a/1190000013661958#item-3-3 D:\course\javaProject\MybatisLearning MySQL基本介绍：https://www.runoob.com/mysql/mysql-install.html TODO 关注的主页和博客参考 Java3y 这位哥们也是刚工作的，写的java知识点大全，写的很不错，学习加交流：https://segmentfault.com/blog/java_3y?page=2]]></content>
      <categories>
        <category>后台技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laugh-moment]]></title>
    <url>%2F2020%2F03%2F15%2Flaugh-moment%2F</url>
    <content type="text"><![CDATA[“其实我挺羡慕火车的” “为什么” “他们连擦肩而过都那么久”]]></content>
      <categories>
        <category>笑</category>
      </categories>
      <tags>
        <tag>生活向</tag>
        <tag>逗比</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周总结]]></title>
    <url>%2F2020%2F03%2F15%2Fweek-summary%2F</url>
    <content type="text"><![CDATA[[toc] 长期的目标 Java基础 微服务框架 sh 脚本 理财入门 大数据 以上描述太过粗糙，待进一步细化。 202003/09 - 03/15 博客使用习惯初步养成，记住了这句话 如果你在输入的时候很爽，那么你在使用的时候肯定很不爽 理财计划开始准备，大腿和渠道初步整理中 听了一次微服务的讲座，搭建一套微服务框架需要学的东西很多，需要加快自己的学习进度 Be brave at the first time, keep someone in the mind and insist on, present what I want to show. 完成Java多线程的写法和多线程管理的方法：如何确保资源共享的准确性？了解了线程状态转换的方法，主动转换相比被动转换的优势在哪？了解避免死锁的方法。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结归纳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理财入门记录]]></title>
    <url>%2F2020%2F03%2F14%2Fmoney-thoughts%2F</url>
    <content type="text"><![CDATA[理财入门的一些想法进入了2020年，新的时代20年代来临，这个时刻真的尤为魔幻。2020是中国实现全面小康的一个标志年，在国家层面是一个关键的时间节点，结果一年伊始，疫情爆发，世界格局正在发生某种从未用过的动荡，反馈到股市上，一场魔幻涨跌大戏正在上演，生逢其时，真的是时刻在见证历史，我都想用上波澜壮阔这种词语来形容自己这个时代了。动荡的时机，本质来看，就是一场资源的重分配，凶险中孕育着的都是机会，试问谁想旁观历史，而不跃跃欲试，投身其中呢？我也想。 去年毕业入职，到今年，我转正了，正式宣告自己脱离了学生身份，在见证历史的这个星期，我领取了人生第一份正式工资，从千级迈入了万级，数量级的提升极大膨胀我的某种莫名奇妙的自信——我有闲钱了啊，我怎么可以让自己的钱只是在账户里“躺尸”。 这个星期，也切实经历一次与理财相关的实践，买了人生第一份保险，给自己，给父母。切实感觉到跟钱相关的玩法切实蕴含各种智慧，愈发觉得有趣。 伴随着雨声，昨晚确实睡了一个好觉，早上起来，看到美股突然全线飘红，这种理财的意动真是瞬间火山喷发。但是万事都有章法，冲动行事最多成为那一撮翠绿绿的韭菜。抱大腿，补基础，双管齐下才是正道。 所以，开始吧！]]></content>
      <categories>
        <category>理财</category>
      </categories>
      <tags>
        <tag>理财</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作随记]]></title>
    <url>%2F2020%2F03%2F11%2Fwork-thoughts%2F</url>
    <content type="text"><![CDATA[记一次建行大学分享讲座time:2020/03/11 今天参与上海分行开发一处分享微服务实践的讲座，并浏览了他们团队的confluence，很有意思的一个团队，心向往之。 所在团队也面临着技术转型，今天讲座分享的一整套微服务框架实践方案确实很有吸引力，希望能汲取其中的养分，在所在团队做出贡献。见贤思齐焉啊，加油吧。 想到这，心理也难免失落，身边如果有这样一个团队就好了，一个人前进的力量太缓慢了。不够脚下的路都是自己选择的结果，机会会给有准备的人，所以即使龟速前进，也要继续积蓄力量。 今日收获： 开发一处的confluence，实践中可借鉴 java springboot 微服务很好玩，继续坚持这条路走下去吧 流程性工作怎么做好呢？今天发现自己上线前的准备还是遗漏了一个事情，就是用户测试报告，同时对上线的材料准备时间节点都没有卡的很好，导致最后手忙脚乱，怎么办比较好？ 流程性的东西整理成一个思维导图，可以使用百度的process on，封板前两天拿出来核对一遍。 思维导图上体现两点：何时何事 when and what。思维导图整理好了，贴在下面提醒自己。]]></content>
      <categories>
        <category>工作心得</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[朴素想法在实际中的应用]]></title>
    <url>%2F2020%2F03%2F11%2Fsimple-philosophy-apply%2F</url>
    <content type="text"><![CDATA[TCP/IP协议的三次握手TCP协议是规定网络建立连接的方法，需要经历三次对话（握手）才能建立连接，进行数据传输。为什么需要三次握手？之前是理解不了第三次握手的必要性，觉得多余。 今天理解这个疑惑的来源：连接的两端分别为A、B，我只站在连接的发起方A考虑，导致的。 这里的朴素想法：请求和响应是一体。 A发起请求，得到B的响应，做出判断；B发起请求，得到A的响应，做出判断；都可做出判断，且判断一致，连接建立就牢不可破。不要担心思维不缜密，遗漏某些特殊情况。# 初步思考一个问题的方法图形化思维当学习一个新的概念（偏向于过程），步骤如下： 明确涉及的对象：发起方/接收方，请求方/接受方 明确每个对象的功能和属性 在脑海中形成对象之间的作用关系图。 检验你学习或者思考的成效的方法，就是看看自己脑子是否有对应的图形。# 具体化思维一个抽象概念很难理解和记忆，每一个难以理解的东西重点在于： 找到一个对应的例子记忆。 故事是容易记忆的，容易表达的。 分析问题的维度当一个问题需要不同维度分析的时候，记得基本的两个维度：空间和时间。 比如分析线程之间的信息共享时候信息不同步问题，先了解线程信息共享的图形化。然后从空间分析，存储共享变量的地方是否会不同步。从时间分析，同一个时刻是否会有多个操作冲突。]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>零碎想法</tag>
        <tag>灵感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何发布一篇帖子]]></title>
    <url>%2F2020%2F01%2F22%2Fblog-user-tutorial%2F</url>
    <content type="text"><![CDATA[提交一篇post基本操作 进入d://Blog/sourceFile/ 新建post: hexo new post PathName 编辑文本：使用Typora编辑文本 hexo g :编译 hexo s：本地展示 hexo d：推送到线上 查看生成结果（需要等待一段时间） Blog的搭建参考参考的教程]]></content>
      <categories>
        <category>使用说明书</category>
      </categories>
      <tags>
        <tag>tutorial</tag>
      </tags>
  </entry>
</search>
