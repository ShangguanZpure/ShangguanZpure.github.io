<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2023年希望做到的事情]]></title>
    <url>%2F2023%2F01%2F03%2F2023target%2F</url>
    <content type="text"><![CDATA[work 数据分析能力 产出一份数据分析工具或者方法论，看到一个类型的数据先走一下这几个流程 Flink环境搭建并开始自学 使用自定义算子完成开发调试并上线 流畅使用shell运维 -shell三剑客grep/awk/sed 项目管理能力提升 life 健身学完冲动买下的这套课程吧！上头买的课程，含着泪也要学完！(只要233，美好身材背回家)[https://www.bilibili.com/cheese/play/ss1312?bsource=link_copy]]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>flag</tag>
        <tag>目标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[年终总结-2022]]></title>
    <url>%2F2022%2F12%2F31%2FannualPersonalSummary%2F</url>
    <content type="text"><![CDATA[疫情之后，日子是以周为单位有一搭没一搭的往前走着，48个来回，一年要过去了。 整理一堆有的没的文档，那顺便写写总结吧。2022，自己关键词有哪一些呢？第一个应该是：分类。收纳分类。工作时日一长，屋子的东西开始慢慢的增多，收纳对我一个懒人来说太过艰巨，怎么办呢？我发现每件物件在进入自己的小窝时候就有意识的开始做分类，这个问题就解决了大半，袜子放一起，上衣放一起，裤子放一起，饮品放一起，零食放一起……，事事有个粗分类，后续的可维护性就变高了，收纳也便成了一件我还可以勉强做到的事情。顺便说一句题外话，数据存数据库的分区也是类似的思路。收藏夹分类。进我的收藏夹吃灰吧应该是我日常常规操作了。收藏的那一时刻，常常会对于自己能发现这么宝贵的资料感到窃喜不已，但是往往就没有了后续。分类有效解决了这个问题，我将浏览器收藏夹分为装机必备、工作、技术、生活、近期在看、牛人牛事，然后让自己闲的蛋疼的时候养成点击文件夹的习惯，一段时间后，确认效果显著（前提是忍痛卸载了各种短视频应用）。第二个是：大件。每年都应该来一个大家伙，今年它来了———— 学习组装了自己的第一台主机。组装的快乐真的太快乐了，感谢B站的全网最好的装机教程，没有之一第三个是：决赛圈。今年好像进了好几个决赛圈，建模的、游戏的、运动的、还有疫情的……，想想，觉得还挺逗的。第四个是：专注。发现自己排计划时候就是把自己想的很牛逼，排的很满，生怕浪费周末的一个早上或者一个下午，过大的任务期望导致的是巨大的启动压力，拖延症状也因此形成。今年开始，慢慢发现，其实一天很短啊，上午9点到11点也就是真正踏踏实实坐下来可以做事的时间，两个小时，发发呆，打两把游戏，可能也就一下过去了，下午2点到6点三个小时也就三个小时，加上运动时间、洗簌时间、收纳时间……，一天真的短暂，能够在一天留下一会的专注时间，其实就可以对自己say yes了。不同于校园，工作后的成长，不在于一时的自律，在于长期的规律生活和自在的心态。自在的心态确实让专注变得顺其自然。另外，放松的方法并不是让大脑停止思考，做一个漫无目的的游戈，而是“换个脑子”，让自己专注到另外一件事上去，可以是学一首歌，打一场球，练一会字，而不是刷电子媒体的视频流和信息流。视频流和信息流的知识洪海对疲惫的大脑来说是更大的负担。这个实践好像有效的缓解“老年痴呆”。第五个是：量子物理。一直在思考，有哪些东西是自己如果财富自由后，还会去追求的东西呢？或许物理和数学才是开始的兴趣点。今年重新开始阅读一些物理的科普读物和科幻读物，发现有的时候好的引导真的太重要了，希望自己重新捡起来。作品相关：上帝是个程序员：游戏制作人眼中的量子物理 有什么话要对2023的自己说呢？照顾好自己的身体。保持简单。有书就好好读，有事就好好做，到了睡觉时间就好好睡，遇到喜欢的人就勇敢去追，被人拒绝了就体面离开。多留下文字，好记性不如烂笔头。一周一周的时间，文字可以是很好的留痕器。 如果10年的我遇到现在的我，他应该还是嘲笑吧，那就嘲笑吧。]]></content>
      <categories>
        <category>年终总结</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建模基本流程]]></title>
    <url>%2F2022%2F03%2F31%2F%E5%BB%BA%E6%A8%A1%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[之前做的笔记 特征工程（周二构造一个版本） 基础特征构造 done 数据预处理：删、填 特征衍生：DFS/CNN done apart 特征变换：特征分布可视化 特征筛选 变量重要性 移除低方差：筛选方差为0 模型筛选（L1正则、树模型）目前都用lightgbm来做了 用sns可视化 变量相关性评估 卡方检验 x,y之间比较 皮尔逊相关系数 R x1,x2之间的比较 用于去重 方差膨胀系数 VIF 变量稳定性评估 PSI 跨时间交叉检验（取多个模型变量的交集，但是要小心共性特征，不一定每次都要在模型中，因为可能是两个共性特征的任一个进入模型，严格取交集会导致共性特征都取不到） 样本不均衡问题 后续考虑 模型调参（周三之前）目标函数选择 binary 评估指标选择 auc LightGBM调参 lightGBM调参 -first 模型融合]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>技术</tag>
        <tag>建模</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何阅读一本书-吴军]]></title>
    <url>%2F2021%2F11%2F18%2Fdushusuibi%2F</url>
    <content type="text"><![CDATA[如何去阅读阅读的层次 第一层次读懂场景和事件 的起因经过结果 第二层次是读懂隐藏的信息，这需要我们对那个时间节点、场景意味有所了解 第三层次，“阅读理解到了深层次，其实就是读书上升到读人” 我有读懂读者内心的作品和经历吗？ “作者将小说中的人物塑造成特定的样式，并不是想编一个故事让我们在茶余饭后挤出两滴泪水，也不是想通过情节牵引我们的好奇心，而是想告诉我们，他们所处的世界以及他们希望的世界是什么样子的” 需要我们对那个时间节点、场景意味有所了解？如何做到呢？ 需要某个领域知识体系，如何高效构建？ 找正统的入门级书籍、课程、资料（我对历史感兴趣：阅读 斯塔夫里阿诺斯的《全球通史》，对金融感兴趣，阅读 Campbell R. McConnell 的《经济学》） 找权威的综述文章 找有趣的专著 怎么检测自己是否在有效构建呢？ 列出过去两三年阅读过某个领域的书籍 接下来一年里打算阅读的书籍和杂志 阅读分清楚主观和客观的信息？ 客观需要考察信息源可靠程度 主观需要注意他得出结论的逻辑 如何提高阅读速度？ 不仅给出方法，也给出很有说服力的例子，吴军老师牛逼啊 要做到有意识的阅读（训练上可以使用语音默读来辅助眼、脑进行同步，这招对我很有效） 提高对文章结构和有用信息的敏感度（文章结构分宏观和微观，有用信息分清主观和客观，注重因，过程，果） 如何体会古典文学的魅力？（这个我之前是真体会不到） 体会不到的原因还在于对时代背景和隐喻无法体会导致的，换句话说，就是还没够到阅读这些名著的信息量的及格线…… 如何去写作写作需要有轮廓-你整体的看法和态度，细节-支持看法和态度的证据，以及串起细节的线索 善用比喻、对比和夸张的修辞手法 学会寓情于景，触景生情 如何写好心理活动？通过直接描写人物的心理，或者人物独白来呈现 间接描写，描写人物的形态，表情，动作来呈现，或者借助别人的嘴说出来，由别人的话产生感触和联想 如何叙事学习了叠叙的叙事方式，找一个锚定点 自然顺序S -&gt; D -&gt; M -&gt; D -&gt; E 找到锚定点 M 多线叙事： M -&gt; D M - - &gt; S -&gt; D 直到两条线重合，揭示谜底后再顺叙 锚定点事最先与读者见面的事件，一定要吸引人。 日常实用写作写日记 最好的写作训练手段 写什么？ 工作经历 读书笔记 特殊经历 怎么写？ 过滤内容，只写一件事 目的性明确，多做总结]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>读书笔记</tag>
        <tag>方法论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python错误输出和日志模块]]></title>
    <url>%2F2021%2F11%2F18%2Fpython_error_logging%2F</url>
    <content type="text"><![CDATA[python 错误日志输出123456 # 堆栈格式化输出import tracebacktry: print('error')except Exception as e: print(traceback.format_exc()) python日志模块使用如何让python日志自动归档？]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>技术</tag>
        <tag>python</tag>
        <tag>logger</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[风控学习笔记]]></title>
    <url>%2F2021%2F11%2F18%2Frisk-learning%2F</url>
    <content type="text"><![CDATA[评价指标KS指标/PSI指标KS评价变量对结果的区分度PSI评价变量对与结果影响是否稳定（相对时间） 基本术语A/B/C卡A ：applicationB : BeahaviorC : cuishou 树模型与规则挖掘（第二课时）单变量分析link: https://www.jianshu.com/p/13c19bbd550d zip 函数 dataframe 根据列表初始化 sorted(ite_obj, key= ，reverse=) 自定义排序 line 画单变量图形 树模型的一些疑惑 为什么ID3树 特征取值较多的值 信息熵比较小 如何克服？ CART树的回归是怎么划分出R个集合的呢？ 基于决策树规则挖掘油品贷案例link: https://www.jianshu.com/p/13c19bbd550d 做了什么数据清洗呢？ id去重、缺失值填充 dp.drop_duplicates() dp.fillna() 做了哪些数据衍生？ 一些时间跨度统计、常规统计 groupby().apply().reset_index() dp.sort_values() dp.merge() 训练的目标是什么？为什么使用回归决策树进行训练呢？ （第三课时）特征工程基于时间序列进行特征衍生: 学习pandas和numpy 的加工语句 基础特征构造 数据预处理：删、填 特征衍生：DFS/CNN 特征变换 特征筛选 skl pkgs提供的工具 filter 根据计算指标筛选 移除低方差：筛选方差为0 单变量特征选择：相关性分析 卡方检验 x,y之间比较 皮尔逊相关系数 x1,x2之间的比较 用于去重 方差膨胀系数 VIF wrapper 递归特征消除 embedded 利用模型来筛选（主流方法，机器学习方法） 实操 会遇到的问题 模型效果不好（大概率 数据集本身就有问题） 训练集效果好，跨时间测试效果不好（样本分布不一致导致 入模变量不对 需要根据跨时间样本调整入模变量 查看PSI值） 跨时间测试效果好，上线之后效果不好（线上线下模型变量逻辑有问题） 上线之后效果好，几周之后分数分布开始下滑 上线后一到两个月比较稳定，突然分数骤降（一般是外部环境、业务运营） 没有明显问题，但是模型每个月逐步失效（普遍行为） 怎么解决这些问题（在建模过程） 变量有贡献 变量线性无关 逻辑回归评分卡希望变量呈现单调趋势（业务角度也希望） 样本分布稳定性评估PSI 模型的PSI、变量的PSI 操作步骤： 变量重要性 IV值（woe值） 卡方检验 模型筛选（L1正则、树模型）目前都用XGboost来做了 变量相关性评估 皮尔逊相关系数 R 方差膨胀系数 VIF 变量稳定性评估 PSI 跨时间交叉检验（取多个模型变量的交集，但是要小心共性特征，不一定每次都要在模型中，因为可能是两个共性特征的任一个进入模型，严格取交集会导致共性特征都取不到） 作业： 上诉用到的指标在代码中的写法都熟悉下 特征衍生前进行特征变量筛选? 一般不会 （第四课时）逻辑回归与评分卡训练逻辑回归课程上讲的太乱太快、不细致找到一个实战 例子 需要后续深入研究的知识点 如何做分箱操作 什么变量需要做分箱 binning 如何分箱 如何判断分箱的好坏 建立评分模型分数划分和贷后监控]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>技术</tag>
        <tag>建模</tag>
        <tag>风控</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell基本知识]]></title>
    <url>%2F2021%2F11%2F08%2Ffunda_shell%2F</url>
    <content type="text"><![CDATA[varshell_var=’lover’如果使用${shell_var}赋值+字符串拼接shell_var=”${shell_var}abcd” shell 循环12345shell_var='aaa'for((i=1;i&lt;10;i++));do...done 传参第n个参数 $n , n={0,1,2,3…}判断第n个参数存不存在 1234if [ ! -n '$1' ];then echo "aaa" exit 1fi 执行结果返回想返回什么数值，就使用echo输出 12345# shell script tmp.shecho 'aaaa'#获取返回值 并赋值给相关变量shell_var=$&#123;sh tmp.sh&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>技术</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组建自己的Mac生态]]></title>
    <url>%2F2021%2F10%2F18%2Fmac-config%2F</url>
    <content type="text"><![CDATA[装饰自己的Terminal安装了Homebrew（配置了清华源）安装搜索homebrewCN安装了iterm2并配置主题（主题未设置好）官网下载 配置主题安装目录激活主题 墙外shodowsocks 建立自己的Blog 使用git 建立博客的指南 建立自己的开发生态编辑器 vscode idea 计划管理 Microsoft To Do]]></content>
      <categories>
        <category>装机必备</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息熵的理解和应用]]></title>
    <url>%2F2021%2F09%2F18%2Fentropy%2F</url>
    <content type="text"><![CDATA[信息的定义信息是对事件不确定性的消除，不确定性越大，信息量越大。 概率与信息量关系：概率越大的事件，提供的信息量越小，概率越小的事件，信息量越大。 信息的度量在数学上的具体表达式应该是什么样子呢？ 数学上一般是这么确认： 信息需要具备什么性质（特性） 尝试构造一个具备这些性质的表达式 证明这个表达式具备唯一性（反证法） 信息的性质： 设 $a_1,a_2$ 是两个随机事件，对应信息量 $f(a_1),f(a_2)$ 若 $P(a_1)\leq P(a_2)$ ，则 $f(a_1) \geq f(a_2)$​​​ $P(a_1)=0$ , $f(a_1)=\infty$ $P(a_1)=1$，$f(a_1)=0$ 若 $a_1，a_2$ 是独立事件，$f(a_1,a_2)=f(a_1)+f(a_2)$​ 满足上诉性质的表达式是$$I(a_i)=log\frac{1}{P(a_i)}$$ 以后看到表达式里面有 $log\frac1{P(a_i)}$就是代表事件 $a_i$ 的信息量 信息熵的定义和衍生量接下来引入随机变量(或者随机分布) $X$$$X={x_1,x_2,…,x_N},\X具备N个状态\P(X)={p(x_1),p(x_2),…,p(x_N)}\P(x)就是X的随机分布$$$X$ 的平均度量，就是信息熵$$H(X)=E(log\frac1{P(X)})=\sum_{x \in X}p(x)log\frac1{p(x)}=-\sum_{x \in X}p(x)logp(x)$$熵的性质 $P(X)$ 为等概率分布时候，$H(X)$ 最大 熵可以理解为是随机变量的信息度量，在这个理解层面拓展，研究多个随机变量之间的关系，可以衍生出联合熵、条件熵、互信息，它们之间的关系可以用集合的维恩图^1表示：$$I(X;Y)=H(X,Y)-H(X|Y)=H(X)+H(Y)-H(X,Y)$$熵也可以理解是对一种随机分布的信息量的度量，在这个理解层面上拓展，研究多个随机分布之间的关系，可以衍生出交叉熵和K- L散度。 前面提及的范围都是对一种分布来讨论，下面讨论对同一个事件（具备N个状态）两种分布 $P={p_1,p_2,…,p_k,…,p_N}$ ，$Q={q_1,q_2,…,q_k,…,q_N}$ 消除分布 $P$ 的不确定性需要最小的信息量（最优确认策略）是 $H(P)$ ， 那么，当我们使用非最优策略（根据分布 $Q$ 制定）消除系统的不确定性，所需要付出的信息量的大小（努力程度）我们该如何去衡量呢？ 这就需要引入交叉熵，其用来衡量在给定的真实分布下，使用非真实分布所指定的策略消除系统的不确定性所需要信息量（付出的努力的大小）。 使用分布 $Q$制定策略，对于 $k$ 状态，需要的信息量为 $log\frac1{q_k}$，因此交叉熵为$$H(P||Q)=\sum_{k=1}^N{p_klog\frac1{q_k}}$$相对熵 $D(P||Q)$ 表示非最优策略和最优策略之间的差异，度量了从Q分布逼近P分布信息量差异（具有方向性）,$$\begin{align}&amp;D(P||Q)= H(P||Q)-H(P)\&amp;= \sum_{k=1}^N{p_klog\frac1{q_k}}-\sum_{k=1}^N{p_klog\frac1{p_k}}\&amp;=\sum_{k=1}^N{p_klog\frac{p_k}{q_k}}\end{align}$$相对熵就是 $K-L$ 散度。 为了消除K-L散度的方向性，引入K-L距离，衡量两个分布之间的差异。$$\begin{align}&amp;D(P||Q)+D(Q||P)\&amp;=\sum_{k=1}^N{p_klog\frac{p_k}{q_k}}+\sum_{k=1}^N{q_klog\frac{q_k}{p_k}}\&amp;=\sum_{k=1}^N(p_k-q_k)log\frac{p_k}{q_k}\&amp;=\sum_{k=1}^N(p_k-q_k)(log{p_k}-log{q_k})\end{align}$$ K-L 距离的使用相对熵与IV的关系 将K-L距离中的两个随机分布p、q换为模型预测后得到的正负样本的概率密度函数f(p|B)和f(p|G)就是IV 相对熵与PSI的关系 PSI本质上是实际分布（A）与预期分布（E）的K-L散度的一个对称化操作]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>建模</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask 学习笔记]]></title>
    <url>%2F2021%2F09%2F08%2Fpython-flask%2F</url>
    <content type="text"><![CDATA[[toc] flask运行环境设置在docker中安装base镜像 centos新建容器 centos-python-webcentos 包依赖下载yum install pkg-name 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889# add useradduser antpythonyum install passwdpasswd antpython## add wheel user group for using 'sudo' cmdgpasswd -a antpython wheel## checkout antpython usersudo -iu antpython# init dev-envsudo yum install epel-release## install gcc and ngnixsudo yum install gcc nginxsudo yum install wget# install anacondawget https://repo.continuum.io/archive/Anaconda3-2019.10-Linux-x86_64.shsh Anaconda3-2019.10-Linux-x86_64.sh## activate the ana envsource anaconda3/bin/activate # creat virtual python env## install virtualenv for python env managementpip install virtualenvmkdir myprojectcd myproject/## create virtual envvirtualenv myprojectenv## activate envsource myprojectenv/bin/activate# init flask apppip install uwsgi flask# write a flask app # from flask import Flask # application = Flask(__name__) # @application.route('/') # def Hello(): # return "Hello There!" # if __name__ == '__main__': # application.run(host='0.0.0.0')# in order to link container and local, need open sys 5000 port# when the docker container creats, bind the port# create the wsgi web server## create the flask web app run methordvim mywsgi.py #from myproject import application #if __name__ == '__main__': # application.run()## test the run by wsginohup uwsgi --socket 0.0.0.0:5000 --protocol=http -w mywsgi &amp;## config uwsgi cfg-filevim myproject.ini # [uwsgi] # module = mywsgi # master = true # processes = 5 # threads = 100 # http = 0.0.0.0:5000 # virtualenv = /home/antpython/myproject/myprojectenv # die-on-term = true# run uwsgi by cfg-fileuwsgi --ini myproject.ini# set the restart script: the linux-sys restart then the python-web restartvim myproject.service # [Unit] # Description=uWSGI instance to serve myproject # After=network.target # [Service] # User=antpython # Group=nginx # WorkingDirectory=/home/antpython/myproject # Environment="PATH=/home/antpython/myproject/myprojectenv/bin" # ExecStart=/home/antpython/myproject/myprojectenv/bin/uwsgi --ini myproject.inisudo systemctl start myproject.servicesudo systemctl enable myproject.service##testsudo reboot now python pip下载安装包以及其依赖，到指定目录123pip freeze &gt; requirements.txtpip download -d DIR -r requirements.txtpip install --no-index --find-links=DIR -r requirements.txt conda 多版本环境切换123conda create -n your_env_name python=x.xconda activate your_env_nameconda deactivate]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>技术</tag>
        <tag>python</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode 刷题笔记]]></title>
    <url>%2F2021%2F08%2F16%2Fleetcode-daily%2F</url>
    <content type="text"><![CDATA[环境信息 原帖链接：leetcode-pdf git 管理 ide：vscode 开发语言：java + python 那些还未掌握的思路深度优先搜索+路径记录 深度优先搜索，就是一种遍历的方式，优先使用递归的写法，可以让自己更专注处理好对遍历当前节点处理时候，更为集中精力。 这道例题很好的说明处理遍历节点的骚操作，就是专注眼前，化繁为简（二叉树的每个节点事同质的，所以专注处理一个节点就可以，节点的串联关系交给遍历就可以） 123456789def dfs(root, sum): if root is None: return path.append(root.val) #处理当前节点 if root.val == sum and root.left is None and root.right is None: res.append(path.copy()) # 终止条件 dfs(root.left, sum - root.val) dfs(root.right, sum - root.val) path.pop() # 骚操作]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[盛夏未来观后感]]></title>
    <url>%2F2021%2F08%2F13%2Fshengxiaoweilai%2F</url>
    <content type="text"><![CDATA[盛夏未来 一直是找不到重点的絮絮叨叨，所以这是一篇有一搭没一搭 没重点的观后感 散文还讲究形散神不散 这一篇连神都没有 但是还是有一种倾诉欲 想把那些感触的点记下来 看这部电影前，我跟朋友说，盛夏未来即便是一部烂俗狗血的青春片，冲着吴磊和张子枫的颜，我应该也可以很享受的看完，这两位真的完完全全长在我的审美点上。吴磊的俊朗的大男孩子气质大概就是我灵魂的样子吧……，张子枫眉清目秀，搭上直挺的鼻子，这种柔中带刚的气质完全把我吃的死死的。 电影是在厦门拍的，这是我看的第一部在厦门拍摄的电影 剧里的场景感觉很熟悉又很陌生 能看到我在厦门生活的味道 可是剧里的场景我都没有去过 就感觉 生活的这些美好 我却一直没去发现 发现美的眼睛都半快蒙尘了 看着电影里面的场景——在海边聊天 在教室听歌 我发现厦门的阳光真的好美 照在脸上 那种干净纯粹的味道 就是厦门这座城带给我最美的礼物 既然电影里的这些场景这么棒 我都没去过 那是不是该行动起来呢 我收录下信息 一定要积极出去打卡 这些地点有： 中学-找不到是哪里 离家出走的那个地下过道-泉州甲第门文创园 有两座大桥的-翔安地铁桥吗 剧情上，校园生活拍的很自然，片中的学生群演们太棒了，操场跑步、班级活动起哄，还有开明又负责又幽默又善良的班主任，大家都点到为止，老师给吴磊、张子枫的训话，哦，是谈话，完全没有以上对下的怒喝和暴力，都是自然通透的交谈，郝蕾的妈妈就更棒了，那种生活的味道真的让这部剧都带上很多的烟火气，但是这个烟火气是带着淡淡的清香的，很对厦门这座城市的气质，爱死厦门这股子朴实的烟火气味道了，如果它的房价不那么高的话…… 张子枫演技真的好棒啊，吴磊带着她到礼堂拍抖音宣布恋情这一段，两人假装在一起宣布爱情的样子 那里面张子枫的那些微表情和动作真的完全感觉她那时刻就是那个样子 那种小心翼翼的开心 真的好开心 我们喜欢的人却不喜欢你 张子枫的无数的演绎细节 让我深切感受到 那种开心中缺失实实在在的悲伤 我能感受到 这个高三的女孩子有着早已她年龄的成熟和坚持 同时又是活泼开朗的 这就是初恋的完美模板吗 又想起吴磊和张子枫给郝蕾和祖峰在出租车旁配音的这一段 这种神来之笔 在这部电影中有很多 真的好加分 吴磊伴奏 女主演唱拥抱这一段 简直了 这就是最美好的青春经历吧 “这首拥抱的remix版本世上只此一版，微信传给你了” 吴磊这句话撩人而不自知啊 remix版本我强烈推荐出QQ音乐版本 我要收藏 我要单曲循环！！ 即使这么优秀的青春片 现在的我看 已没有当年看怦然心动的那种心悸和感情汹涌 社会沉浮两年有余 一心搞钱 已经让这些微末的情绪触觉在慢慢的钝化了 没有办法做到那种带入别人情景的感同深受了 张子枫的角色 其实感情世界挺复杂的 有必须面对父母婚姻破裂又尝试挽回的纠结 有在爱的人面前相处的心动和压抑的喜悦 有小鹿乱撞到不可控的爱意汹涌而出 有爱而不得的揭开彼此的伤疤…… 那种青春里的感情冲撞 经历过就算真的成长了吧 故事结尾说， 彼此奔赴的相爱希望在未来有 会有的 在未来那个热烈的盛夏 。 记于 2021.08.13 1:00:09]]></content>
      <categories>
        <category>观后感</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>观后感</tag>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 数据处理]]></title>
    <url>%2F2021%2F07%2F24%2Fpython-data-process%2F</url>
    <content type="text"><![CDATA[统计比例]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>技术</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker容器学习笔记-1]]></title>
    <url>%2F2021%2F07%2F18%2Fdocker-1%2F</url>
    <content type="text"><![CDATA[容器是什么？有什么用？ what why容器是？ 软件打包技术容器是主机上的一个独立进程，容器里面装的是一个个镜像；镜像是服务更高一层的封装和打包，包含更多的基础信息，比如依赖包、配置文件、脚本、二进制文件、环境变量等。容器是虚拟化技术的集大成者。有什么用？ 容器提供一整套更为便捷的服务打包和部署方式。容器是一种好用、快速的统一规范，是的各种交接流程简单、独立、隔离。 不知大家是否意识到，潘多拉盒子已经被打开。容器不但降低了我们学习新技术的门槛，更提高了效率。 “That isolation leverages kernel namespaces and cgroups, features that have been in Linux for a long time.”这一句英语怎么翻译？ CLI：command-line interface docker基本框架 how 底层： runtime 管理工具： docker engine 提供操作接口 定义工具： docker file 生成 docker image 存放在docker registries 很多好的image 放在 docker Hub 为了让docker安全稳定的运行 需要一系列可靠的工具 所以有了容器平台技术 包含管理分布式集群的容器编排技术 在这个基础上还有 支持一键部署等更抽象一层的容器管理平台和一系列的支持技术，支持技术的内容一般都是这几样：网络关系管理、服务发现、监控、数据管理、日志管理、安全性 目前找不到好的一个形象比喻，把它们好好串联起来 docker的镜像base -&gt; 可以共享base 比喻：多个不同楼房可以共用一个地基， 或者是共用前N层（N &gt; = 0) copy-on-write：镜像只可读 不可写 可以复用 因为写才会产生冲突 写都在各自容器的容器层写 docker初体验参考的教程是在ubantu系统，我在Mac系统，所以我先看官方的入门介绍链接为：https://docs.docker.com/get-started/ 设置docker的镜像源不设置的话，根本无法下载远程仓库资源，我设置的是亚马逊和网易源设置方式参见这个链接： https://zhuanlan.zhihu.com/p/146876547 http://t.zoukankan.com/aric2016-p-12423226.html https://blog.csdn.net/u012081441/article/details/104553145/ dockerFile 配置和运行dockerFile 运行先看看本层的镜像层是否已经存在，存在直接复用，不存在新建临时容器运行配置的命令后commmit为新的镜像层（有commit ID）如此往复 直到结束。 Dockerfile常用指令docker 仓库的使用repository 的完整格式为：[registry-host]:[port]/[username]/xxx例如： [host]:5000/sgzc/httpd:v1 docker 基本操作镜像常用操作images 显示镜像列表 history 显示镜像构建历史 commit 从容器创建新镜像 build 从 Dockerfile 构建镜像 tag 给镜像打 tag pull 从 registry 下载镜像 push 将 镜像 上传到 registry rmi 删除 Docker host 中的镜像 search 搜索 Docker Hub 中的镜像 容器常用操作docker run –name “container-name” -d create 创建容器 run 运行容器 pause 暂停容器 unpause 取消暂停继续运行容器 stop 发送 SIGTERM 停止容器 kill 发送 SIGKILL 快速停止容器 start 启动容器 restart 重启容器 attach attach 到容器启动进程的终端 exec 在容器中启动新进程，通常使用 “-it” 参数 logs 显示容器启动进程的控制台输出，用 “-f” 持续打印 rm 从磁盘中删除容器 参考资料 官方文档：https://docs.docker.com/get-started 每日五分钟系列]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>技术</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理财笔记]]></title>
    <url>%2F2021%2F07%2F18%2Ftake-money%2F</url>
    <content type="text"><![CDATA[十年十倍熟悉了两种买入策略： 价值投资：持有最小PE的股票 五日轮换 不知道价值何时体现 熬不过去 提前止损 趋势投资：“红三兵策略” 连续三个交易日上涨买入 盈利5%卖出 刻舟求剑]]></content>
      <categories>
        <category>理财</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>理财</tag>
        <tag>基金</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公式之美书籍阅读笔记]]></title>
    <url>%2F2021%2F07%2F18%2Fthe-beauty-of-formula%2F</url>
    <content type="text"><![CDATA[1+1=2勾股定理费马大定理牛顿-莱布尼兹公式柯西公式]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>读书</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask-framework]]></title>
    <url>%2F2020%2F11%2F16%2Fflask-framework%2F</url>
    <content type="text"><![CDATA[Flask框架升级研究[toc] WEB是什么Web应用的本质就是： 浏览器发送一个HTTP请求； 服务器收到请求，生成一个HTML文档； 服务器把HTML文档作为HTTP响应的Body发送给浏览器； 浏览器收到HTTP响应，从HTTP Body取出HTML文档并显示。 接受HTTP请求、解析HTTP请求、发送HTTP响应都是苦力活，如果我们自己来写这些底层代码，还没开始写动态HTML呢，就得花个把月去读HTTP规范。 正确的做法是底层代码由专门的服务器软件实现，我们用Python专注于生成HTML文档 WSGI规定了这些底层代码的规范 有很多项目组实现了这个规范 编写了很多服务器 例如：？？ WSGI是说明书 ？？是依据说明书生产出来的机器 参考链接【1】WEB开发入门介绍 【2】python web部署整体介绍]]></content>
  </entry>
  <entry>
    <title><![CDATA[python-funda]]></title>
    <url>%2F2020%2F10%2F21%2Fpython-funda%2F</url>
    <content type="text"><![CDATA[[TOC] 包导入和自定义包Python模块查找路径import 语句执行时候，Python会查找相应的模块并导入，顺序为： 先查找内置模块 查找sys.path（先查找当前目录文件，PATHONPATH，系统PATH） _init_.py__init__.py 在包被导入时会被执行,为所在包进行一些初始化操作，不在所在包则不生效。 用于 导入该模块该目录下需要用到的一些依赖或者其他一些初始化操作。 如何自制包在包的最外层同级目录新建setup.py 运行 Python setup.py sdist 如何下载依赖安装包直接Google 依赖包==版本号，下载即可。 .whl文件安装方法：pip install &lt;pkg.whl&gt; .tar.gz文件：tar -zxvf &lt;.tar.gz&gt; -C ./ python setup.py install]]></content>
  </entry>
  <entry>
    <title><![CDATA[photo-learning]]></title>
    <url>%2F2020%2F10%2F06%2Fphoto-learning%2F</url>
    <content type="text"><![CDATA[[TOC] 需要的材料书籍纽约摄影教程 关注的人photo: 学习调色，弄懂调色的参数 @安东尼的调色日记 vedio: 学习后期剪辑Pr @Hivi 另外就是多看关注列表的摄影师吧，发现宝藏后也要经常看。]]></content>
  </entry>
  <entry>
    <title><![CDATA[sklearnNote]]></title>
    <url>%2F2020%2F08%2F27%2FsklearnNote%2F</url>
    <content type="text"><![CDATA[整体介绍模型公共部署，提供python传统机器学习模型（XGBoost,Sklearn模型）部署和计算服务。 具体为：业务方将需要部署的模型文件（XGB方式打包、Sklearn方式打包）交由引擎部署，业务方通过请求报文发起请求服务到引擎，引擎送入模型计算并以报文方式返回计算结果。 交易码：A0942A406 接口规范请求报文格式：（新增申请件编号字段 todo） 申请件编号 调用模型文件名称 请求信息json串 返回报文格式：（AplId中的A改为小写 todo） 申请件编号 服务响应状态代码（01 success 00 fail) 返回信息json串 12345678910111213141516171819202122232425262728293031323334353637//请求json信息&#123; //"traceId": "", //交易流水号 VMD中加入 "aplId": "", //申请件编号 "bsnName": "", //业务名称 模型放置在该目录下 "modType": "", //对应机器学习模型类型：XGB/LR/SKL_COMMOD "modName": "", //模型文件名称 "packPKLAppro": "", //模型KPL的封装方式 1 SKL_JOBLIB 2 SKL_PICKLE 3 XGB "aplParams": &#123; "":"", "":"" &#125; //模型的输入参数&#125;//返回的json信息//统一格式//正确返回&#123; "pre_results": "[0.06245352]", //模型的返回结果 "aplId": "test001", //申请件ID "sysRespCode": "201", //返回状态码 成功201 失败 500 "rspInf": "success" //返回状态具体描述&#125;//错误返回&#123; "aplId": "null", //申请件ID "sysRespCode": "500", //返回状态码 "rspInf": "Exception('请求信息解析出错')" //返回状态具体描述&#125;//LR模型返回（特殊）&#123; "pre_labels": "0", "pre_probas": "0.879682,0.120308,0.000011", "aplId": "test001", "sysRespCode": "201", "rspInf": "success"&#125; 流程 请求解析为模型输入格式 下载模型 模型预测 编辑返回结果并返回 测试开启flask调试模式 XGB模型和LR模型正确请求测试 done 动态新增模型是否可动态加载 done 请求信息有错误下处理方法：缺失请求信息，请求信息格式，内容错误 done 请求信息为空 请求信息不是post请求 done Questions python LR 逻辑回归 预测变量中有缺失值如何处理? 引擎不处理 vscode 组织python工程的方法之后学习（包含导包、调试），目前先临时测试下自己写的代码，然后放到linux上面去测试，先完成开发 模型描述唯一标识添加模型类别 modTarget：回归 or 分类(不需要，因为SKL的预测函数都是model.predict()) 模型类型modType：LR、XGB、SKL_COMMOD（SKL提供的模型方法） 模型打包方式modPKLAppro： SKL_PICKLE、SKL_JOBLIB、 XGB 注意事项json.dump():转化dict-&gt;str json.dumps():转化dict-&gt;str并存入文件 LR模型12345678#json请求 转化为 array-like"""&#123;"aplParams":"N1,N2,N3,...,Nn"&#125;array([[N1,N2,N3,...,Nn]])""" 123456789101112131415161718192021222324252627282930313233343536373839#封装为PKL文件1. pickle&gt;&gt;&gt; from sklearn import svm&gt;&gt;&gt; from sklearn import datasets&gt;&gt;&gt; clf = svm.SVC()&gt;&gt;&gt; iris = datasets.load_iris()&gt;&gt;&gt; X, y = iris.data, iris.target&gt;&gt;&gt; clf.fit(X, y) SVC(C=1.0, cache_size=200, class_weight=None, coef0=0.0, decision_function_shape=None, degree=3, gamma='auto', kernel='rbf', max_iter=-1, probability=False, random_state=None, shrinking=True, tol=0.001, verbose=False)&gt;&gt;&gt; import pickle&gt;&gt;&gt; s = pickle.dumps(clf)&gt;&gt;&gt; clf2 = pickle.loads(s)&gt;&gt;&gt; clf2.predict(X[0:1])array([0])&gt;&gt;&gt; y[0]2. joblib&gt;&gt;&gt; from sklearn.externals import joblib&gt;&gt;&gt; joblib.dump(clf, 'filename.pkl') &gt;&gt;&gt; clf = joblib.load('filename.pkl')#进行预测以及输出结果&gt;&gt;&gt; from sklearn.datasets import load_iris&gt;&gt;&gt; from sklearn.linear_model import LogisticRegression&gt;&gt;&gt; X, y = load_iris(return_X_y=True)&gt;&gt;&gt; clf = LogisticRegression(random_state=0).fit(X, y)&gt;&gt;&gt; clf.predict(X[:2, :])array([0, 0])&gt;&gt;&gt; clf.predict_proba(X[:2, :])array([[9.8...e-01, 1.8...e-02, 1.4...e-08], [9.7...e-01, 2.8...e-02, ...e-08]])&gt;&gt;&gt; clf.score(X, y)0.97... XGB模型https://cloud.tencent.com/developer/article/1387686 1234567891011121314151617181920# 请求解析为模型输入格式# X_test类型可以是二维List，也可以是numpy的数组 array([[]])dtest = DMatrix(X_test)ans = model.predict(dtest)# 下载模型\模型预测 # 使用XGB.save_model()封装的PKL文件# save modelbst.save_model('xgb.model')# load model and data inbst2 = xgb.Booster(model_file='xgb.model')dtest2 = xgb.DMatrix('dtest.buffer')preds2 = bst2.predict(dtest2) # 使用SKL封装的PKL文件# alternatively, you can pickle the boosterpks = pickle.dumps(bst2)# load model and data inbst3 = pickle.loads(pks)preds3 = bst3.predict(dtest2)# 编辑返回结果并返回pre_output["results"] = str(preds3)]]></content>
  </entry>
  <entry>
    <title><![CDATA[linux-tutorial]]></title>
    <url>%2F2020%2F08%2F22%2Flinux-tutorial%2F</url>
    <content type="text"><![CDATA[[TOC] 快捷键清屏 Ctrl+L shell命令1cp -R -f srcFile tarDir 安装方式需要下载文件 D:\Environment\虚拟机\rhel-8.0-x86_64-dvd.iso 认识linux文件结构和文件操作是什么：结构 怎么做：操作 目录树结构，如何存取文件]]></content>
  </entry>
  <entry>
    <title><![CDATA[git-tutorial]]></title>
    <url>%2F2020%2F04%2F28%2Fgit-tutorial%2F</url>
    <content type="text"><![CDATA[git网上有很多经典的教程，比如廖雪峰的Git教程 不过，秉承“只有自己总结的东西才是自己的”观念，还是做了自己的笔记。 学习的顺序应该为： 学习廖的课程 做自己的笔记，形成自己的知识 再回去好好细读廖的教程，发现一些之前未发现的、未理解的内容 git help 的使用工具，都是熟能生巧。掌握基本方法，多看官方git help 才是正道。 123456# help 功能全览git help# 查看帮助手册git help git# 如果不知道下一步怎么操作git status #git status会列出当前的状态，并提示接下来的操作！！ git的优势 分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！ 远程库既可以作为备份，又可以让其他人通过该仓库来协作。 因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。 git线上网页版使用说明git本地提交之后，线上有个最后审核步骤，有实操后总结在这里。 git的基本操作安装git官网下载，一路next。（windows） 设置username和email123# --global是全局参数，对局部仓库也可以单独设置name和email$ git config --global user.name "Your Name"$ git config --global user.email "email@example.com" 使用SSH协议连接本地库与远程库id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 123456# 本地的git仓库与远程库使用SSH（secure shell）进行加密传输# 本地创建SSH Key # 查看根目录下是否有.ssh文件，以及.ssh/id_rsa 和.ssh/id_rsa_pub文件是否存在 #不存在 ssh -keygen -t rsa -C "youremail@example.com"# 将公钥放在GitHub上面 为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。 当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。 最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。 摘抄自https://www.liaoxuefeng.com/wiki/896043488029600/896954117292416 Q: 远程库有什么用呢？ A: GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作 先有本地库，再有远程库本地仓库初始化 123456# 仓库 repository# 本地仓库初始化git init# 查看git配置文件ls -ah# 或者克隆远程库git clone（TODO） 本地文件新建提交仓库 1234# 多次add 一次提交git add fileName1git add fileName2git commit -m "comment content" 提交完毕复核 12345678# 修改了fileName1git status# 查看某个文件修改前后差别（已经 add了会回退到未add状态）# 脑中要有文件状态转换图（第一幅图）# ！！diff 比较的是 add之前和之后文件的差异！！git diff fileName1git add fileName1git commit -m "revise fileName1" 版本回退（游戏存档读档） 1234567891011# commit的作用类似于*存档*，当出现意外，可以回到这个存档点重新开始# 查看存档点,存档点是一个HEAD指针，HEAD^表示当前存档点的前一个存档点，HEAD^^上上存档点# HEAD~100：前100个存档点git log#简洁版展示git log --pretty=oneline#显示commit id git relog#跳转到指定存档点 #HEAD指针可以是: 1. HEAD^这种类型的 2.指定的commit idgit reset --hard HEAD指针 必须记住的第一张图(图一)：文件的状态流转图 图中存在四个对象： 工作区 workspace 版本库 repository 暂存区 stage 主分支 master 包含的内容上：{stage} &gt;= {master} 详说git diff 12345# 根据图一# 比较工作区workspace与暂存区stage的区别git diff# 比较版本库主分支master与工作区workspace的区别git diff HEAD -- fileName 撤销修改 第6点说到的版本回退是指stage与master一致下（stage为空），将当前maste版本切换回之前的master版本，工作区同步修改。 撤销修改指的是撤销一个小的改动，涉及workspace/repository/stage/master之间状态的转移。 123456789#工作区修改，暂存区和主分支没有变化 撤销修改git status #根据提示敲入下一行命令git restore fileName #撤销工作区的修改（本质是用版本库覆盖工作区）#工作区修改，提交到暂存区，主分支没有变化 撤销修改git statusgit restore --unstage fileName #撤销暂存区的修改git restore fileName #撤销工作区的修改# 修改已经commit 撤销修改(版本回退)git reset --hard HEAD^ 文件删除12345678910111213141516# 新增文件并add、commitgit add test.txtgit commit -m "add test.txt"$ git statusOn branch masterChanges not staged for commit: (use "git add/rm &lt;file&gt;..." to update what will be committed) (use "git restore &lt;file&gt;..." to discard changes in working directory) deleted: test.txt#根据提示 # 如果本地删除是误操作git restore test.txt # 如果确实删除某个文件git add test.txt # orgit rm test.txtgit commit -m "delete test.txt" 建立远程库分支与本地分支连接123456789101112131415# 1.先有本地库，再有远程库 # 1.1 与远程仓库建立连接 # 连接远程（remote）添加git@github.com:ShanggguanZpure/learn.git为远程仓库，并命名为origin git remote add origin git@github.com:ShangguanZpure/learngit.git # 1.2 将本地文件推送到远程库对应分支 #第一次提交:关联（-u）本地master分支内容到远程仓库（origin）的master分支,并推送（push）本地master分支内容到远程仓库（origin）的master分支 git push -u origin master #第二次及以上提交：本地推送到远程仓库的master git push origin master # 推送本地指定分支（branch-name）到远程库(origin)指定分支(origin/branch-name) git push origin branch-name origin/branch-name #远程分支可以省略，会找对应分支合并 # 2.先有远程库，再有本地库 # 克隆远程库内容git clone git@github.com:ShangguanZpure/gitskills.git 分支管理什么时候建立分支分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。 现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。 创建与合并分支123456789101112131415161718192021222324# 查看分支：git branch#创建分支：git branch &lt;name&gt;#切换分支：git checkout &lt;name&gt; #或者git switch &lt;name&gt;#创建+切换分支：git checkout -b &lt;name&gt; #或者git switch -c &lt;name&gt;#合并某分支到当前分支：git merge &lt;name&gt;#删除分支：git branch -d &lt;name&gt;#分支合并默认为fast forward,并且删除分支后，合并记录不保留，使用 --no-ff就会按照普通模式合并，并做一次commit提交，可以保留合并记录。举例如下： git switch -c dev vi readme.txt #修改readme.txt文件进行保存 git add readme.txt git commit -m "merge -no-ff test" git switch master git merge --no-ff -m "merge with dev" dev git branch -d dev git log --graph --pretty=oneline --abbrrev-commit 解决冲突12345678910# 产生冲突的原因：两个分支修改了同一个地方，且不一致。git merge feature1 #产生冲突vi conflictedFileName#手动修改不一致地方git add conflictedFileNamegit commit -m "conflict fixed"#删除分支git branch -d feature1#查看分支合并图$ git log --graph --pretty=oneline --abbrev-commit Bug分支：修复紧急Bug操作暂存（stash）现有分支的工作，切换到Bug分支修复（待测试） 1234567891011121314151617181920212223242526272829#当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交.# 1.存放dev分支工作区和暂存区的内容，包含：暂存区未提交的内容（暂存区与主分支区别），工作区未提交到暂存区的内容（工作区与暂存区的区别）workspace - stage - mastergit stash# 2. 确认在哪个分支上修复（假设为master，当然也可以是其他分支）git switch master# 3.从master分支新建Bug分支git switch -c issue-101# 4.修复Bug# 5.提交修改git add readme.txtgit commit -m "fix bug 101"# 6.切换到主分支，提交修改git switch mastergit merge --no-ff -m "merged bug fix 101" issue-101# 7.切换回dev分支继续开发git switch dev# 8.查看dev分支状态git statusgit stash list #！！！# 9.恢复之前暂存的内容git stash apply #拉取git stash drop #删除 #上面两步合成一步git stash pop #你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash git stash apply stash@&#123;0&#125;# 在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick &lt;commit&gt;命令，把bug提交的修改“复制”到当前分支，避免重复劳动。git cherry-pick 4c805e2 #！！！ Feature 分支:开发新功能开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D强行删除。 多人协作123456789101112131415161718192021222324252627282930# 查看远程库的信息$ git remote -vorigin git@github.com:michaelliao/learngit.git (fetch)origin git@github.com:michaelliao/learngit.git (push)# 推送分支 #推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上 #全格式是： git push &lt;remote&gt; local-branch-name remote/branch-name(可以省略最后一项） $ git push origin master #推送其他分支，比如dev，就改成 $ git push origin dev# 抓取分支 #要在dev分支上开发，就必须创建远程origin的dev分支到本地 $ git checkout -b dev origin/dev# 本地分支提交远程分支产生冲突 #先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送 $ git pull There is no tracking information for the current branch. Please specify which branch you want to merge with. See git-pull(1) for details. git pull &lt;remote&gt; &lt;branch&gt; If you wish to set tracking information for this branch you can do so with: git branch --set-upstream-to=origin/&lt;branch&gt; dev #git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接： $ git branch --set-upstream-to=origin/dev dev Branch 'dev' set up to track remote branch 'dev' from 'origin'. # 解决冲突后再次push $ git push origin dev commit log管理merge操作会产生一些merge commit的提交，意义不明且冗余，应该去除。 主要有以下两种情形： 多人在同一个远程分支Feature上协作，需要多次git pull别人的提交到本地合并，在合并完之后，还没push之前，使用git rebase可以将分支合并的操作整合成一条直线。 也可以是 git pull --rebase (等价于git fetch + git rebase) 背景： 本地master分支在commit1处新建分支feature，feature分支上有提交一次feature_commit1，master分支自己独立提交了一次commit2 动作： 现在feature分支合并master分支的commit2，方便做下一步开发 具体操作: 为了使得合并之后feature分支的提交记录git log --graph --pretty=oneline --abbrev-commit是一条直线，没有分叉，采用: git rebase master 本地自己独立的一个分支other（实现特定功能）合并到 dev 分支，分支other多次提交过于琐碎，希望合成一个，使用git merge --squash other,git commit -m &quot;Message&quot;。 参考： 1.https://www.liaoxuefeng.com/wiki/896043488029600/1216289527823648 2.https://blog.csdn.net/themagickeyjianan/article/details/80333645?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2 标签 tagTODO 先有远程库，再有本地库本地仓库初始化1234# 根据SSH协议，克隆（clone）版本库git@github.com:ShangguanZpure/gitskills.git到当前目录git clone git@github.com:ShangguanZpure/gitskills.git# 当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin# 从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支 多人协作123456789101112131415161718192021222324252627282930# 查看远程库的信息$ git remote -vorigin git@github.com:michaelliao/learngit.git (fetch)origin git@github.com:michaelliao/learngit.git (push)# 推送分支 #推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上 #全格式是： git push &lt;remote&gt; local-branch-name remote/branch-name(可以省略最后一项） $ git push origin master #推送其他分支，比如dev，就改成 $ git push origin dev# 抓取分支 #要在dev分支上开发，就必须创建远程origin的dev分支到本地 $ git checkout -b dev origin/dev# 本地分支提交远程分支产生冲突 #先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送 $ git pull There is no tracking information for the current branch. Please specify which branch you want to merge with. See git-pull(1) for details. git pull &lt;remote&gt; &lt;branch&gt; If you wish to set tracking information for this branch you can do so with: git branch --set-upstream-to=origin/&lt;branch&gt; dev #git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接： $ git branch --set-upstream-to=origin/dev dev Branch 'dev' set up to track remote branch 'dev' from 'origin'. # 解决冲突后再次push $ git push origin dev 小结 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 自定义Gitgit的进阶操作记录一次合并分支探索：一开始的master分支git log: 1234$ git log --graph --pretty=oneline --abbrev-commit* 45edb69 (HEAD -&gt; master, origin/master, origin/feature, feature)revisereadme.txt* b2b4a71 add featureFile* 007eea3 branch master commit 新建一个 branchOne 分支，并做两次提交： 12345* 5847216 (HEAD -&gt; branchOne) branch one commit second* 6afe53f branch one commit first* 45edb69 (origin/master, origin/feature, master, feature) revise readme.txt* b2b4a71 add featureFile* 007eea3 branch master commit master分支在提交一次： 1234* c0ed012 (HEAD -&gt; master) master commit first* 45edb69 (origin/master, origin/feature, feature) revise readme.txt* b2b4a71 add featureFile* 007eea3 branch master commit、 新建 branchTwo 分支，并做一次提交： 12345* 838a94c (HEAD -&gt; branchTwo) branch two commit first* c0ed012 (master) master commit first* 45edb69 (origin/master, origin/feature, feature) revise readme.txt* b2b4a71 add featureFile* 007eea3 branch master commit 123456789101112131415161718192021222324252627282930313233343536373839404142#master合并branchOne* d3a3350 (HEAD -&gt; master) Merge branch 'branchOne'|\| * 5847216 (origin/branchOne, branchOne) branch one commit second| * 6afe53f branch one commit first* | c0ed012 (origin/master) master commit first|/* 45edb69 (origin/feature, feature) revise readme.txt* b2b4a71 add featureFile* 007eea3 branch master commit#紧接着branchTwo 合并主分支做下一步的开发* a3f215e (HEAD -&gt; branchTwo) Merge branch 'master' into branchTwo|\| * d3a3350 (master) Merge branch 'branchOne'| |\| | * 5847216 (origin/branchOne, branchOne) branch one commit second| | * 6afe53f branch one commit first* | | 838a94c (origin/branchTwo) branch two commit first|/ /* | c0ed012 (origin/master) master commit first#branchTwo开发后提交一次commit,合并到主分支master #no-ff* e867107 (HEAD -&gt; master) Merge branch 'branchTwo'|\| * 4474480 (branchTwo) branch two commit second| * a3f215e Merge branch 'master' into branchTwo| |\| |/|/|* | d3a3350 Merge branch 'branchOne'|\ \| * | 5847216 (origin/branchOne, branchOne) branch one commit second| * | 6afe53f branch one commit first| | * 838a94c (origin/branchTwo) branch two commit first| |/|/|* | c0ed012 (origin/master) master commit first|/* 45edb69 (origin/feature, feature) revise readme.txt* b2b4a71 add featureFile* 007eea3 branch master commit 总结：一开始的分支状态 合并的顺序为 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#实现branchTwo是在branchOne开发完成后才从主分支master拉出。# master git merge --no-ff branchOne* ea91fc4 (HEAD -&gt; master) Merge branch 'branchOne'|\| * 5847216 (origin/branchOne, branchOne) branch one commit second| * 6afe53f branch one commit first* | c0ed012 master commit first|/* 45edb69 (origin/feature, feature) revise readme.txt* b2b4a71 add featureFile* 007eea3 branch master commit# branchTwo git checkout branchTwogit rebase master #合并前* 838a94c (HEAD -&gt; branchTwo, origin/branchTwo) branch two commit first* c0ed012 master commit first* 45edb69 (origin/feature, feature) revise readme.txt* b2b4a71 add featureFile* 007eea3 branch master commit #合并后* 29755bf (HEAD -&gt; branchTwo) branch two commit first* ea91fc4 (master) Merge branch 'branchOne'|\| * 5847216 (origin/branchOne, branchOne) branch one commit second| * 6afe53f branch one commit first* | c0ed012 master commit first|/* 45edb69 (origin/feature, feature) revise readme.txt* b2b4a71 add featureFile* 007eea3 branch master commit######可以看到，branchTwo从原来的分叉点master commit first 移动到了 Merge branch 'branchOne'#这样就可以认为branchTwo是在branchOne开发完成后才从主分支master拉出。#######主分支 mastergit merge --no-ff branchTwo* 93e5997 (HEAD -&gt; master) Merge branch 'branchTwo'|\| * 29755bf (branchTwo) branch two commit first|/* ea91fc4 Merge branch 'branchOne'|\| * 5847216 (origin/branchOne, branchOne) branch one commit second| * 6afe53f branch one commit first* | c0ed012 master commit first|/* 45edb69 (origin/feature, feature) revise readme.txt* b2b4a71 add featureFile* 007eea3 branch master commit git使用的注意事项疑问1、 123456789101112131415161718192021222324$ git reflogf7d7681 (HEAD -&gt; master) HEAD@&#123;0&#125;: commit (merge): conflict fixed8957634 HEAD@&#123;1&#125;: commit: &amp; simple5f311b8 HEAD@&#123;2&#125;: checkout: moving from feature1 to masterc4d3fa9 (feature1) HEAD@&#123;3&#125;: commit: AND simple5f311b8 HEAD@&#123;4&#125;: checkout: moving from master to feature15f311b8 HEAD@&#123;5&#125;: merge dev: Fast-forward0da8bf7 (origin/master) HEAD@&#123;6&#125;: checkout: moving from dev to master5f311b8 HEAD@&#123;7&#125;: commit: branch test0da8bf7 (origin/master) HEAD@&#123;8&#125;: checkout: moving from master to dev0da8bf7 (origin/master) HEAD@&#123;9&#125;: commit: delete test.txt09915bb HEAD@&#123;10&#125;: commit: add test.txt131ea24 HEAD@&#123;11&#125;: reset: moving to HEAD^7fe3d31 HEAD@&#123;12&#125;: commit: error content commit131ea24 HEAD@&#123;13&#125;: commit: git tracks changesd0950e0 HEAD@&#123;14&#125;: commit: understand how stage worksd576e2b HEAD@&#123;15&#125;: reset: moving to d576e2bd87032b HEAD@&#123;16&#125;: reset: moving to HEAD^d576e2b HEAD@&#123;17&#125;: commit: add GPLd87032b HEAD@&#123;18&#125;: commit: add distribuye951d21f HEAD@&#123;19&#125;: commit (initial): creat a readme file# 第二列表示什么呢？表示具体的指针指向的位置。本地master指向“conflict fixed”。# 远程的master分支（origin/master）指向哪里呢？看到提交过程中多次出现？按理说，没有push操作，远程库应该没有变动才对。]]></content>
      <categories>
        <category>基础工具使用</category>
      </categories>
      <tags>
        <tag>管理工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[text-editor-skills]]></title>
    <url>%2F2020%2F04%2F21%2Ftext-editor-skills%2F</url>
    <content type="text"><![CDATA[文本编辑小技巧列编辑Notepad++中： 设置中首选项选择类操作许可，按住alt选中编辑的行，即可进行列元素的操作。、 比如统一的首字母大写。 批量替换给每行的开头统一添加相同内容方法： 回车换行的文本符号为\r\t 匹配每行的\r\t，替换为\r\tAddContent即可]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>文本编辑</tag>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[周日总结]]></title>
    <url>%2F2020%2F04%2F19%2F2020-04-19-summary%2F</url>
    <content type="text"><![CDATA[最近比较颓废，工作上的事情不是特别紧急，空余下来的时间里面却不想做什么事情，懒癌发作，彻底成为积极向上时候的自己最讨厌的那种人。 有自己的时间是一件多幸运的事情，可以继续了解学习自己的爱好方面的知识，比如自己之前刚开了一个头的唱歌技巧学习的坑，还为此写了一篇日记记录唱歌技巧学习笔记，可是我没有点开继续学习。为什么呢，不是特别喜欢唱歌吗，怎么就没有激情了呢？也许是认识到自己唱歌气息控制不好，声音也不好听，还找不到音准等等缺点，打击到积极性了。既然把唱歌当成自己一项爱好，那么还是坚持住，唱歌技巧的教程要看完的(TODO)。 空余的时间也是给自己技术能力充电的好机会啊，可是也没有珍惜这段时间去做这件事。想了下，也是遇到了一个小困难，刚好看到java基本类库的使用，要去了解java基本类库的用法，枯燥乏味还要记忆，因此打击了学习的积极性。这个时候其实更应该克服，学不下去的时候那就好好做好笔记(TODO)，方便下次学习更有效率些。 当然，话说话来，人的活力总有上有下，处于低谷期，什么都不做，放空下自己也没有错啦，让自己晚上刷手机刷到困，早上睡到自然醒，看看电影，补补电视剧《清平乐》，看看综艺《王牌对王牌》，听听音乐《歌手》也不见得就不好。就是怕放开自律，就如脱缰野马，难以回性，写到这里算是给自己一个提醒。 无聊时间也会想起久未联系的朋友，约着喝喝奶茶，聊聊天，刚好也能联络联络感情，但是不好的一点就是自己嘴巴还是太碎，说话也过于零散，没能良好互动，希望之后注意让自己说话有个中心，给对方留足反馈时间，形成良好交流(TODO)。 最近觉得不错的一个事情，那就是跑步还是坚持下来了，这点特别好，继续坚持吧！ 有果必有因，为啥最近会懒癌发作呢？自己觉得根源还是在职业规划上的迷惑以及学习任务艰巨两方面引起的。职业规划上，觉得银行的技术只要够用就可以，自己是无法有效得到提升的，技术提升慢的同时技术价值在行内并没有业务价值高，但是难受在业务能力提升的方法和途径自己并未有所得，提升进展缓慢。思虑职业规划同时还要学习海量的java知识，心态上隐隐觉得hold不住，因为目前看进展也很慢，才看完Spring的IOC和AOP，java基础也看了50%而已，后续等着我的还有linux运维基本知识（视频B站已收藏，183讲），SSM框架的Struts和Mybatis。 怎么办呢？ 职业规划上，先争取做好分内技术工作吧，也就是SSM框架熟悉起来，会基本的linux运维，学习数据库的基本知识，等技术的工作做完后，再发力熟悉目前正在做的业务。时间上安排，就是上半年结束之前，SSM框架熟悉完毕，今年过后，linux运维和数据库也小有了解。明年再发力开始熟悉业务。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结归纳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-funda-class]]></title>
    <url>%2F2020%2F04%2F16%2Fjava-funda-class%2F</url>
    <content type="text"><![CDATA[Java数字类1234567891011121314151617181920//double 和 float不能表示精确的小数//常规类型表示有范围限制//引入BigInterger和BigDecimal，没有范围限制//BigDecimal初始化尽量用字符串，使用double类型不准确BigDecimal bigDecimal = new BigDecimal("10");BigDecimal bigDecimal = new BigDecimal(2.3);//out:2.29365453658662... //BigDecimal做除法，记得限制输入位数System.out.println( bigDecimal.divide(new BigDecimal("3"), 3, BigDecimal.ROUND_HALF_UP));//随机数类//使用Random类或者Math.random()//具体的随机数范围查看源码注释确认Random rd = new Random();rd.nextInt();rd.nextInt(10);//[0,10)间rd.nextDouble();//[0.0,1.0)间rd.ints(5,10,100);//返回10-100之间的5个随机数Math.random();//[0.0,1.0)间System.out.println(Math.round(Math.random()*10)); 字符串相关类字符串相关类基本都要背，因为太常用了。 String类是不可变对象，concat等改变的操作都会产生一个新的对象。 123456789101112131415161718192021222324String str = "123,456,789,/*/";//增System.out.println(str.concat("aaaa"));//删、改System.out.println(str.substring(2,4));System.out.println(str.replace("123", "321"));System.out.println(str.replaceAll("[*]", "??")); //第一个表达式是正则表达式System.out.println(str.split(","));System.out.println(str.trim());//查System.out.println(str.charAt(0));System.out.println(str.concat("123"));System.out.println(str.contains("123"));System.out.println(str.indexOf("123"));System.out.println(str.length());System.out.println(str.isEmpty());//空的判断与念出来的含义相符合：如果数组不为空if(!str.isEmpty())&#123; System.out.println("no empty");&#125;//可变长字符对象有StringBuffer和StringBuilder//StringBuffer是线程同步的//StringBuilder线程不同步//.append()功能速度上StringBuilder&gt;StringBuffer&gt;String 日期相关类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//Calendarimport java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date; public class MyCalendar &#123; //格式化声明 private static SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); //日期实例 private static Calendar startDate = Calendar.getInstance(); private static Calendar endDate = Calendar.getInstance(); private static DateFormat df = DateFormat.getDateInstance(); private static Date earlydate = new Date(); private static Date latedate = new Date(); /** * 计算两个时间相差多少个年 * * @param early * @param late * @return * @throws ParseException */ public static int yearsBetween(String start, String end) throws ParseException &#123; //Str -&gt; format -&gt; set startDate.setTime(sdf.parse(start)); endDate.setTime(sdf.parse(end)); return (endDate.get(Calendar.YEAR) - startDate.get(Calendar.YEAR)); &#125; /** * 计算两个时间相差多少个月 * * @param date1 * &lt;String&gt; * @param date2 * &lt;String&gt; * @return int * @throws ParseException */ public static int monthsBetween(String start, String end) throws ParseException &#123; startDate.setTime(sdf.parse(start)); endDate.setTime(sdf.parse(end)); int result = yearsBetween(start, end) * 12 + endDate.get(Calendar.MONTH) - startDate.get(Calendar.MONTH); return result == 0 ? 1 : Math.abs(result); &#125;————————————————版权声明：本文为CSDN博主「浅沫微雨」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/L_hb123/java/article/details/59058209]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[qing-ping-le]]></title>
    <url>%2F2020%2F04%2F11%2Fqing-ping-le%2F</url>
    <content type="text"><![CDATA[官家关于大赦天下答大娘娘的话矛盾点：你把反对我的人都赦免了，告述天下朝堂已在你的掌控之中，你这是为我祈福吗？ 官家站在大娘娘的角度考虑，同意部分大娘娘的说法，但是把原因和目的上升到一个更高的维度，符合双方共同的着力点——维护大宋的江山去说明：反对你的那些人是眼光狭隘了些，但是也不是什么大奸大恶之人，还是忠君为国的能臣，释放他们让他们继续发光发热不正是为了让大宋更加的繁荣吗？]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>观后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[json解析]]></title>
    <url>%2F2020%2F04%2F09%2Fjava-json-object%2F</url>
    <content type="text"><![CDATA[json用法使用阿里的fastjson包。 1234567891011121314151617//用到的两个类import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject;//javaObj 到 jsonSrt（两种方法）String jsonStr = JSON.toJSONString(Obj);String jsonStr = JSONObject.toJSONString(Obj); //jsonStr 到javaObj（两种方法） //(1) jsonStr -&gt; JSONObject -&gt; javaObjJSONObject jsonObj = JSON.parseObject(jsonStr); //jsonStr -&gt; JSONObjectObject javaObj = JSON.toJavaObject(jsonObj, Object.class); //JSONObject -&gt; javaObj //(2)Object obj = JSON.parseObject(jsonStr, Object.class);//jsonStr -&gt; javaObj//写jsonStr注意json串的引号需要转义String jsonString = "&#123;\"name\":38,\"name\":\"mkyong\"&#125;"; 对象中有空值的处理方法(手动处理): 1234567891011class MyObject&#123;&#125;//对象转化为json对象obj -&gt; jsonStr -&gt; JSONObject;JSONObject jsonObj = JSON.parseJson(JSON.toJsonString(MyObject));//获取对象的成员变量 //反射方法获取（todo）//创建HashMap&lt;String, Object&gt; jsonMap,成员变量为key，jsonObj.get(key)为valueif(jsonObj.get(key) == null)&#123; jsonMap(key, "");&#125;else&#123; jsonMap(key, jsonObj.get(key));&#125; 例子（测试包含json串嵌套的场景通过） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.alibaba.fastjson.serializer.SerializerFeature;/** * JSON 转换 */public final class JsonUtils &#123; /** * 把Java对象转换成json字符串 * * @param object 待转化为JSON字符串的Java对象 * @return json 串 or null */ public static &lt;T&gt; String parseObjToJson(T object) &#123; String string = null; try &#123; //string = JSON.toJSONString(object); string = JSONObject.toJSONString(object, SerializerFeature.PrettyFormat); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; return string; &#125; /** * 将Json字符串信息转换成对应的Java对象 * * @param json json字符串对象 * @param c 对应的类型 */ public static &lt;T&gt; T parseJsonToObj(String json, Class&lt;T&gt; c) &#123; try &#123; //两个都是可行的，起码我测试的时候是没问题的。 //JSONObject jsonObject = JSONObject.parseObject(json);// JSONObject jsonObject = JSON.parseObject(json);// return JSON.toJavaObject(jsonObject, c); return JSON.parseObject(json, c); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; return null; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>技术文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sing_a-song]]></title>
    <url>%2F2020%2F04%2F04%2Fsing-a-song%2F</url>
    <content type="text"><![CDATA[唱歌技巧参考视频教程 第一节：使用气息 如何吸气（腹式呼吸） 练习方法： 吸气，气沉小腹，嘟嘴巴唱“都咧咪法搜”； 小诀窍：叹气的感觉，狗喘气 什么时候吸气 多听歌。 气息怎么控制： 深呼吸，憋气，加动作辅助（下蹲） 小诀窍：气往下沉，高音才上的去 第二节：找到声音的位置 说话 唱歌 微笑！打开口盖 开口音：a a a a a 闭口音：mi yi yi yi yi 分别说和唱的区别 感觉有没有用上气息 共鸣 胸腔共鸣 手放在胸前 气下沉 振动 鼻腔共鸣 手指放在鼻子，气下沉 头腔共鸣 手指一直往上找最高音，气下沉 使用颤音]]></content>
      <categories>
        <category>生活向</category>
      </categories>
      <tags>
        <tag>唱歌技巧</tag>
        <tag>喜欢的歌</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[兼听则明]]></title>
    <url>%2F2020%2F03%2F31%2F2020-03-31%2F</url>
    <content type="text"><![CDATA[我对综艺节目歌手关注越来越少了，今年注意到的时候已经播出两期了。节目虽然没看，倒是在知乎看到的些许的讨论，讨论的一个焦点是华晨宇，另一个便是黄霄云。那会关于黄霄云的讨论重点一个是说她专捡软柿子捏，奇袭毛不易，一个是说炫技大过于表达，还有一个是说情商不行的。一通这么漫无目的的浏览下来，对于黄的歌唱实力顶尖、唯比赛论和情商待提高的固执小姑凉形象就形成了。这之后开始看黄的表演就觉得歌唱的很好，但是就觉得太比赛化，唱的很动听，却没能打动我。 今天歌单随机播放循环到了一首《连名带姓》，瞬间被打动了，打开一看，正是黄的演唱，脑海中一些蹦出了疑问：那会歌手舞台听的时候怎么没有感觉？点开歌曲评论，画风与知乎上的风格天差地别，我摘几条： 歌手本来就是综艺，可怜只有黄把它当比赛； 放弃了保研，最后一门课因为档期冲突放弃了； 这届歌手中唯一一个可以让我单曲循环的歌手，其他歌手的歌都没意思，没了黄，甚至不想看，一帮老油条； 汪峰：考中央音乐学院（给你写推荐信） 林俊杰：我想要认识你 萧敬腾：天分的歌者 华晨宇：未来非常顶尖的歌手 键盘侠：没感情，只会炫技，快淘汰吧。 暂不论这些评论的是否有失偏颇，但是确实那个当下让我从正面的视角感受到了黄的认真，想赢的决心，通过《连名带姓》这首歌也感受她的真挚和实力。我诧异自己之前仅仅是看了相关的评论就莫名其妙给人贴上那些恶劣的标签，诧异自己连黄是谁都不知道的情况下就敢武断的做出判断，用有色眼镜去看待她的表演。 于是我不禁思考：一个与我们相隔十万八千里的人，怎么对她产生情感倾向？ 往往我们被动接受各种带着明显的感情倾向讯息，就容易人云亦云，不经思考给别人贴上刻板标签。如果自己亲眼所见的场景让你产生情绪，那这种情绪就是最直接你对这个人的观感，无需怀疑。如果未对一个人所做所为有过亲眼目睹，只是道听、途说，那么不要轻易做出判断，一定要看看好的说法和坏的说法，兼听则明。 对每一件事要有自己发自内心认同的判断，这个判断需要在看到好坏两面后做出。 可能你会说，兼听需要花费时间成本，犯不着这么较真。这也没错，但是如果可以，在给任何一个贴上标签的时候，尽量都慎重些，不了解最好就不做判断，特别是下意识的判断。]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>随想</tag>
        <tag>生活原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[how-to-live]]></title>
    <url>%2F2020%2F03%2F29%2Fhow-to-live%2F</url>
    <content type="text"><![CDATA[周五晚上在学校的论坛浏览后，有一句话一直在脑海中出现，大意是： 生活其实很纯粹，快乐也很简单，在学习的时间学习，累了就在被窝里看一部电影，疗愈自己，看完就乖乖睡觉，不要被那些琐碎的想法纠缠，没有意义。 然后周末下意识按照这样的方式去生活，在起床的时间起床，在学习的时间学习，在休息的时间就真的放下手机，好好休息，在锻炼的时间就穿好装备去锻炼，在被窝的时间就打开一部电影，好好沉浸其中。 自律的感觉、休息的感觉、偷懒的感觉都享受到了，挺不错。 生活本身是复杂的，如何让生活简单快乐是一门艺术啊。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>随想</tag>
        <tag>生活向</tag>
        <tag>零碎想法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[writing-skills]]></title>
    <url>%2F2020%2F03%2F24%2Fwriting-skills%2F</url>
    <content type="text"><![CDATA[知乎评价周杰伦看看人家如何行文，做一下分析记录： 迷茫是年轻人的常事。 我在身边看到了这个时代年轻人的迷茫。我从书里看到了过去很多时代年轻人的迷茫。 身边的朋友对我说，看到许多我们已经习以为常的事情和观点跨越过一代人的鸿沟在上一代人的眼里竟如洪水猛兽般面目可憎，而他们才占据着这个社会的主流。 我告诉他不是这样的。 我给你讲个故事，这个故事是关于周杰伦的。 作者：子由链接：https://www.zhihu.com/question/21850419/answer/204892310来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java线程协作学习]]></title>
    <url>%2F2020%2F03%2F19%2Fexample-for-thread-learnning%2F</url>
    <content type="text"><![CDATA[今天学习Java多线程的协作方法，接触到了几种锁，来规定了多个线程的协作方式，今天的学习方法特别适用于说明例子化学习的好处。 例子化学习就是每一处知识点通过一个例子来比喻或者应用，判断自己掌握这个知识点的方法就是把这个例子说一遍或者实现一遍。 这种方法让每一个知识点在脑海里都是一张图，一个画面，一个场景，积累多了，脑中自成一片天地。 具体到今天的学习： 基本的读写锁Lock 应用于奶茶店买奶茶：顾客买奶茶是单独读线程协作，老板写订单和员工的读订单是分别的读写线程协作，用Lock就可以管理； 计量锁 Semaphone 对应与停车场停车：停车场的大小是固定的，多车是否可以停车，停车线程的管理用Semaphone锁管理； 门闩锁 Latch锁 对应 百米赛跑。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>随想</tag>
        <tag>总结</tag>
        <tag>学习原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架]]></title>
    <url>%2F2020%2F03%2F17%2FmicroService%2F</url>
    <content type="text"><![CDATA[自上而下学习什么是SSM框架 Spring学习已经学习结束， 使用的教程：https://www.bilibili.com/video/av47952931 笔记在代码中，在D:\course\javaProject\21-IDEA-projects Mybatis学习实现一个例子：https://segmentfault.com/a/1190000013661958#item-3-3 D:\course\javaProject\MybatisLearning MySQL基本介绍：https://www.runoob.com/mysql/mysql-install.html TODO 关注的主页和博客参考 Java3y 这位哥们也是刚工作的，写的java知识点大全，写的很不错，学习加交流：https://segmentfault.com/blog/java_3y?page=2]]></content>
      <categories>
        <category>后台技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laugh-moment]]></title>
    <url>%2F2020%2F03%2F15%2Flaugh-moment%2F</url>
    <content type="text"><![CDATA[“其实我挺羡慕火车的” “为什么” “他们连擦肩而过都那么久”]]></content>
      <categories>
        <category>笑</category>
      </categories>
      <tags>
        <tag>生活向</tag>
        <tag>逗比</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每周总结]]></title>
    <url>%2F2020%2F03%2F15%2Fweek-summary%2F</url>
    <content type="text"><![CDATA[[toc] 长期的目标 Java基础 微服务框架 sh 脚本 理财入门 大数据 以上描述太过粗糙，待进一步细化。 202003/09 - 03/15 博客使用习惯初步养成，记住了这句话 如果你在输入的时候很爽，那么你在使用的时候肯定很不爽 理财计划开始准备，大腿和渠道初步整理中 听了一次微服务的讲座，搭建一套微服务框架需要学的东西很多，需要加快自己的学习进度 Be brave at the first time, keep someone in the mind and insist on, present what I want to show. 完成Java多线程的写法和多线程管理的方法：如何确保资源共享的准确性？了解了线程状态转换的方法，主动转换相比被动转换的优势在哪？了解避免死锁的方法。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结归纳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理财入门记录]]></title>
    <url>%2F2020%2F03%2F14%2Fmoney-thoughts%2F</url>
    <content type="text"><![CDATA[理财入门的一些想法进入了2020年，新的时代20年代来临，这个时刻真的尤为魔幻。2020是中国实现全面小康的一个标志年，在国家层面是一个关键的时间节点，结果一年伊始，疫情爆发，世界格局正在发生某种从未用过的动荡，反馈到股市上，一场魔幻涨跌大戏正在上演，生逢其时，真的是时刻在见证历史，我都想用上波澜壮阔这种词语来形容自己这个时代了。动荡的时机，本质来看，就是一场资源的重分配，凶险中孕育着的都是机会，试问谁想旁观历史，而不跃跃欲试，投身其中呢？我也想。 去年毕业入职，到今年，我转正了，正式宣告自己脱离了学生身份，在见证历史的这个星期，我领取了人生第一份正式工资，从千级迈入了万级，数量级的提升极大膨胀我的某种莫名奇妙的自信——我有闲钱了啊，我怎么可以让自己的钱只是在账户里“躺尸”。 这个星期，也切实经历一次与理财相关的实践，买了人生第一份保险，给自己，给父母。切实感觉到跟钱相关的玩法切实蕴含各种智慧，愈发觉得有趣。 伴随着雨声，昨晚确实睡了一个好觉，早上起来，看到美股突然全线飘红，这种理财的意动真是瞬间火山喷发。但是万事都有章法，冲动行事最多成为那一撮翠绿绿的韭菜。抱大腿，补基础，双管齐下才是正道。 所以，开始吧！]]></content>
      <categories>
        <category>理财</category>
      </categories>
      <tags>
        <tag>理财</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作随记]]></title>
    <url>%2F2020%2F03%2F11%2Fwork-thoughts%2F</url>
    <content type="text"><![CDATA[记一次建行大学分享讲座time:2020/03/11 今天参与上海分行开发一处分享微服务实践的讲座，并浏览了他们团队的confluence，很有意思的一个团队，心向往之。 所在团队也面临着技术转型，今天讲座分享的一整套微服务框架实践方案确实很有吸引力，希望能汲取其中的养分，在所在团队做出贡献。见贤思齐焉啊，加油吧。 想到这，心理也难免失落，身边如果有这样一个团队就好了，一个人前进的力量太缓慢了。不够脚下的路都是自己选择的结果，机会会给有准备的人，所以即使龟速前进，也要继续积蓄力量。 今日收获： 开发一处的confluence，实践中可借鉴 java springboot 微服务很好玩，继续坚持这条路走下去吧 流程性工作怎么做好呢？今天发现自己上线前的准备还是遗漏了一个事情，就是用户测试报告，同时对上线的材料准备时间节点都没有卡的很好，导致最后手忙脚乱，怎么办比较好？ 流程性的东西整理成一个思维导图，可以使用百度的process on，封板前两天拿出来核对一遍。 思维导图上体现两点：何时何事 when and what。思维导图整理好了，贴在下面提醒自己。]]></content>
      <categories>
        <category>工作心得</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[朴素想法在实际中的应用]]></title>
    <url>%2F2020%2F03%2F11%2Fsimple-philosophy-apply%2F</url>
    <content type="text"><![CDATA[TCP/IP协议的三次握手TCP协议是规定网络建立连接的方法，需要经历三次对话（握手）才能建立连接，进行数据传输。为什么需要三次握手？之前是理解不了第三次握手的必要性，觉得多余。 今天理解这个疑惑的来源：连接的两端分别为A、B，我只站在连接的发起方A考虑，导致的。 这里的朴素想法：请求和响应是一体。 A发起请求，得到B的响应，做出判断；B发起请求，得到A的响应，做出判断；都可做出判断，且判断一致，连接建立就牢不可破。不要担心思维不缜密，遗漏某些特殊情况。# 初步思考一个问题的方法图形化思维当学习一个新的概念（偏向于过程），步骤如下： 明确涉及的对象：发起方/接收方，请求方/接受方 明确每个对象的功能和属性 在脑海中形成对象之间的作用关系图。 检验你学习或者思考的成效的方法，就是看看自己脑子是否有对应的图形。# 具体化思维一个抽象概念很难理解和记忆，每一个难以理解的东西重点在于： 找到一个对应的例子记忆。 故事是容易记忆的，容易表达的。 分析问题的维度当一个问题需要不同维度分析的时候，记得基本的两个维度：空间和时间。 比如分析线程之间的信息共享时候信息不同步问题，先了解线程信息共享的图形化。然后从空间分析，存储共享变量的地方是否会不同步。从时间分析，同一个时刻是否会有多个操作冲突。]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>零碎想法</tag>
        <tag>灵感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何发布一篇帖子]]></title>
    <url>%2F2020%2F01%2F22%2Fblog-user-tutorial%2F</url>
    <content type="text"><![CDATA[提交一篇post基本操作 进入d://Blog/sourceFile/ 新建post: hexo new post PathName 编辑文本：使用Typora编辑文本 hexo g :编译 hexo s：本地展示 hexo d：推送到线上 查看生成结果（需要等待一段时间） Blog的搭建参考参考的教程]]></content>
      <categories>
        <category>使用说明书</category>
      </categories>
      <tags>
        <tag>tutorial</tag>
      </tags>
  </entry>
</search>
